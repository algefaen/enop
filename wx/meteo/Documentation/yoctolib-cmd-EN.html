<HTML>
<HEAD>
<title>CmdLine API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-cmd-EN.html 20916 2015-07-23 08:54:20Z seb $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - -
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce
 *    and Licensee are governed by Yoctopuce General Terms and
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute;
  left:0px;
  top:0px;
  width:800px;
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute;
  left:0px;
  top:80px;
  width:250px;
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;

}

div#FunctionsLayer
{ position:absolute;
  left:250px;
  top:80px;
  width:600px;
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute;
  left:0px;
  top:570px;
  width: 800px;
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute;
  width:10px;
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize;
}

div.container
{ width:100%;
  height:100%;
}

span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
}

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }

span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }

div.methodsList
 { margin-top:0px;
   padding-top:0px;
   padding-left:10px;
   margin-bottom:10px;
 }

div.methodsList A
 { color: navy;
   text-decoration:none;
 }

div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }

span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }

span#pn , td.pn
 { font-weight:bold;
   color:#004000;

 }

td.pn
 {vertical-align:top}

span.paramAndRet
 {font-weight:bold;

 }

table
 {font-size:14px;}

span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;
   background-color: #f8f8f8;
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }

p.protolabel
 { border-top:1px  solid #f0f0f0;
 }

P.protoretval
 { margin-left:20px;}

.paramtable
 { margin-left:20px; margin-top:0px;}

P.protoretval
 { margin-left:20px;}

input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }

td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040;
 }

td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }

p.methodlist
 { border-top:1px solid #e0e0e0;
 }

a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 }

span.synlist
 { margin-left:10px;
 }

p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }
</style>

<SCRIPT type="text/JavaScript">
<!--
var WinW;
var WinH;

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array();
var SVN_Id = '$Id: yoctolib-cmd-EN.html 20916 2015-07-23 08:54:20Z seb $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: VSource)
doc['VSource']={'':{syn:'Voltage source function interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to control the module voltage output. You affect absolute output values or make transitions</p>'}};
doc['VSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'YVSource get_advertisedValue',pro:'YVSource <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters)',ext:''};
doc['VSource']['get_extPowerFailure']={syn:'Returns true if external power supply voltage is too low.',lib:'YVSource get_extPowerFailure',pro:'YVSource <span id=pn>target</span> get_extPowerFailure',cmt:'<p>Returns true if external power supply voltage is too low.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if external power supply voltage is too low',ext:''};
doc['VSource']['get_failure']={syn:'Returns true if the module is in failure mode.',lib:'YVSource get_failure',pro:'YVSource <span id=pn>target</span> get_failure',cmt:'<p>Returns true if the module is in failure mode. More information can be obtained by testing get_overheat, get_overcurrent etc... When a error condition is met, the output voltage is set to z\xE9ro and cannot be changed until the reset() function is called.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the module is in failure mode',ext:''};
doc['VSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'YVSource get_logicalName',pro:'YVSource <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source',ext:''};
doc['VSource']['get_overCurrent']={syn:'Returns true if the appliance connected to the device is too greedy .',lib:'YVSource get_overCurrent',pro:'YVSource <span id=pn>target</span> get_overCurrent',cmt:'<p>Returns true if the appliance connected to the device is too greedy .</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the appliance connected to the device is too greedy',ext:''};
doc['VSource']['get_overHeat']={syn:'Returns TRUE if the module is overheating.',lib:'YVSource get_overHeat',pro:'YVSource <span id=pn>target</span> get_overHeat',cmt:'<p>Returns TRUE if the module is overheating.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to TRUE if the module is overheating',ext:''};
doc['VSource']['get_overLoad']={syn:'Returns true if the device is not able to maintaint the requested voltage output .',lib:'YVSource get_overLoad',pro:'YVSource <span id=pn>target</span> get_overLoad',cmt:'<p>Returns true if the device is not able to maintaint the requested voltage output .</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the device is not able to maintaint the requested voltage output',ext:''};
doc['VSource']['get_regulationFailure']={syn:'Returns true if the voltage output is too high regarding the requested voltage .',lib:'YVSource get_regulationFailure',pro:'YVSource <span id=pn>target</span> get_regulationFailure',cmt:'<p>Returns true if the voltage output is too high regarding the requested voltage .</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the voltage output is too high regarding the requested voltage',ext:''};
doc['VSource']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'YVSource get_unit',pro:'YVSource <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:''};
doc['VSource']['pulse']={syn:'Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.',lib:'YVSource pulse',pro:'YVSource <span id=pn>target</span> pulse <span id=pn>voltage</span> <span id=pn>ms_duration</span>',cmt:'<p>Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.</p>',par:{voltage:'pulse voltage, in millivolts',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['VSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'YVSource set_logicalName',pro:'YVSource <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the voltage source.</p>',par:{newval:'a string corresponding to the logical name of the voltage source'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['VSource']['set_voltage']={syn:'Tunes the device output voltage (milliVolts).',lib:'YVSource set_voltage',pro:'YVSource <span id=pn>target</span> set_voltage <span id=pn>newval</span>',cmt:'<p>Tunes the device output voltage (milliVolts).</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['VSource']['voltageMove']={syn:'Performs a smooth move at constant speed toward a given value.',lib:'YVSource voltageMove',pro:'YVSource <span id=pn>target</span> voltageMove <span id=pn>target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth move at constant speed toward a given value.</p>',par:{target:'new output value at end of transition, in milliVolts.',ms_duration:'transition duration, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: VSource)
//--- (generated code: AnalogSensorS16)
doc['AnalogSensorS16']={'':{syn:'AnalogSensorS16',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['AnalogSensorS16']['get_advertisedValue']={syn:'Returns the current value of $THEFUNCTION$ (no more than 6 characters).',lib:'YAnalogSensorS16 get_advertisedValue',pro:'YAnalogSensorS16 <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of $THEFUNCTION$ (no more than 6 characters).</p>',ret:'a string corresponding to the current value of $THEFUNCTION$ (no more than 6 characters)',ext:''};
doc['AnalogSensorS16']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'YAnalogSensorS16 get_currentRawValue',pro:'YAnalogSensorS16 <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:''};
doc['AnalogSensorS16']['get_currentValue']={syn:'Returns the current measured value.',lib:'YAnalogSensorS16 get_currentValue',pro:'YAnalogSensorS16 <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:''};
doc['AnalogSensorS16']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'YAnalogSensorS16 get_highestValue',pro:'YAnalogSensorS16 <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:''};
doc['AnalogSensorS16']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YAnalogSensorS16 get_logFrequency',pro:'YAnalogSensorS16 <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['AnalogSensorS16']['get_logicalName']={syn:'Returns the logical name of $THEFUNCTION$.',lib:'YAnalogSensorS16 get_logicalName',pro:'YAnalogSensorS16 <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of $THEFUNCTION$.</p>',ret:'a string corresponding to the logical name of $THEFUNCTION$',ext:''};
doc['AnalogSensorS16']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'YAnalogSensorS16 get_lowestValue',pro:'YAnalogSensorS16 <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:''};
doc['AnalogSensorS16']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YAnalogSensorS16 get_reportFrequency',pro:'YAnalogSensorS16 <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['AnalogSensorS16']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YAnalogSensorS16 get_resolution',pro:'YAnalogSensorS16 <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['AnalogSensorS16']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'YAnalogSensorS16 get_unit',pro:'YAnalogSensorS16 <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:''};
doc['AnalogSensorS16']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YAnalogSensorS16 set_highestValue',pro:'YAnalogSensorS16 <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnalogSensorS16']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YAnalogSensorS16 set_logFrequency',pro:'YAnalogSensorS16 <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnalogSensorS16']['set_logicalName']={syn:'Changes the logical name of $THEFUNCTION$.',lib:'YAnalogSensorS16 set_logicalName',pro:'YAnalogSensorS16 <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of $THEFUNCTION$.</p>',par:{newval:'a string corresponding to the logical name of $THEFUNCTION$'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnalogSensorS16']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YAnalogSensorS16 set_lowestValue',pro:'YAnalogSensorS16 <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnalogSensorS16']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YAnalogSensorS16 set_reportFrequency',pro:'YAnalogSensorS16 <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: AnalogSensorS16)
//--- (generated code: Module)
var Language='CmdLine';
var IncludeLabel='';
var ParamLabel='Parameters :';
var ReturnLabel='Returns :';
var AbbrevHint='The API features two syntaxes : one is purely object oriented, the other is more compact.';
var NotFound='No match found';
var AbbrevLabel='Use abbreviated names';
var UseShortcuts=false;
var sub={YAPI_SUCCESS:'SUCCESS',YAPI_NOT_INITIALIZED:'NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'VERSION_MISMATCH',YAPI_DEVICE_BUSY:'DEVICE_BUSY',YAPI_TIMEOUT:'TIMEOUT',YAPI_IO_ERROR:'IO_ERROR',YAPI_NO_MORE_DATA:'NO_MORE_DATA',YAPI_EXHAUSTED:'EXHAUSTED',YAPI_DOUBLE_ACCES:'DOUBLE_ACCES',YAPI_UNAUTHORIZED:'UNAUTHORIZED',YAPI_RTC_NOT_READY:'RTC_NOT_READY',YAPI_FILE_NOT_FOUND:'FILE_NOT_FOUND',null:'NULL'};
doc['Module']={'':{syn:'Module control interface',inc:'',cmt:'<p>This interface is identical for all Yoctopuce USB modules. It can be used to control the module global parameters, and to enumerate the functions provided by each module.</p>'}};
doc['Module']['checkFirmware']={syn:'Tests whether the byn file is valid for this module.',lib:'YModule checkFirmware',pro:'YModule <span id=pn>target</span> checkFirmware <span id=pn>path</span> <span id=pn>onlynew</span>',cmt:'<p>Tests whether the byn file is valid for this module. This method is useful to test if the module needs to be updated. It is possible to pass a directory as argument instead of a file. In this case, this method returns the path of the most recent appropriate byn file. If the parameter onlynew is true, the function discards firmware that are older or equal to the installed firmware.</p>',par:{path:'the path of a byn file or a directory that contains byn files',onlynew:'returns only files that are strictly newer'},ret:': the path of the byn file to use or a empty string if no byn files matches the requirement',ext:''};
doc['Module']['download']={syn:'Downloads the specified built-in file and returns a binary buffer with its content.',lib:'YModule download',pro:'YModule <span id=pn>target</span> download <span id=pn>pathname</span>',cmt:'<p>Downloads the specified built-in file and returns a binary buffer with its content.</p>',par:{pathname:'name of the new file to load'},ret:'a binary buffer with the file content',ext:''};
doc['Module']['get_allSettings']={syn:'Returns all the settings of the module.',lib:'YModule get_allSettings',pro:'YModule <span id=pn>target</span> get_allSettings',cmt:'<p>Returns all the settings of the module. Useful to backup all the logical names and calibrations parameters of a connected module.</p>',ret:'a binary buffer with all the settings.',ext:''};
doc['Module']['get_beacon']={syn:'Returns the state of the localization beacon.',lib:'YModule get_beacon',pro:'YModule <span id=pn>target</span> get_beacon',cmt:'<p>Returns the state of the localization beacon.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the state of the localization beacon',ext:''};
doc['Module']['get_firmwareRelease']={syn:'Returns the version of the firmware embedded in the module.',lib:'YModule get_firmwareRelease',pro:'YModule <span id=pn>target</span> get_firmwareRelease',cmt:'<p>Returns the version of the firmware embedded in the module.</p>',ret:'a string corresponding to the version of the firmware embedded in the module',ext:''};
doc['Module']['get_icon2d']={syn:'Returns the icon of the module.',lib:'YModule get_icon2d',pro:'YModule <span id=pn>target</span> get_icon2d',cmt:'<p>Returns the icon of the module. The icon is a PNG image and does not exceeds 1536 bytes.</p>',ret:'a binary buffer with module icon, in png format. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_lastLogs']={syn:'Returns a string with last logs of the module.',lib:'YModule get_lastLogs',pro:'YModule <span id=pn>target</span> get_lastLogs',cmt:'<p>Returns a string with last logs of the module. This method return only logs that are still in the module.</p>',ret:'a string with last logs of the module. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_logicalName']={syn:'Returns the logical name of the module.',lib:'YModule get_logicalName',pro:'YModule <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the module.</p>',ret:'a string corresponding to the logical name of the module',ext:''};
doc['Module']['get_luminosity']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'YModule get_luminosity',pro:'YModule <span id=pn>target</span> get_luminosity',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:''};
doc['Module']['get_persistentSettings']={syn:'Returns the current state of persistent module settings.',lib:'YModule get_persistentSettings',pro:'YModule <span id=pn>target</span> get_persistentSettings',cmt:'<p>Returns the current state of persistent module settings.</p>',ret:'a value among <tt>LOADED</tt>, <tt>SAVED</tt> and <tt>MODIFIED</tt> corresponding to the current state of persistent module settings',ext:''};
doc['Module']['get_productId']={syn:'Returns the USB device identifier of the module.',lib:'YModule get_productId',pro:'YModule <span id=pn>target</span> get_productId',cmt:'<p>Returns the USB device identifier of the module.</p>',ret:'an integer corresponding to the USB device identifier of the module',ext:''};
doc['Module']['get_productName']={syn:'Returns the commercial name of the module, as set by the factory.',lib:'YModule get_productName',pro:'YModule <span id=pn>target</span> get_productName',cmt:'<p>Returns the commercial name of the module, as set by the factory.</p>',ret:'a string corresponding to the commercial name of the module, as set by the factory',ext:''};
doc['Module']['get_productRelease']={syn:'Returns the hardware release version of the module.',lib:'YModule get_productRelease',pro:'YModule <span id=pn>target</span> get_productRelease',cmt:'<p>Returns the hardware release version of the module.</p>',ret:'an integer corresponding to the hardware release version of the module',ext:''};
doc['Module']['get_rebootCountdown']={syn:'Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.',lib:'YModule get_rebootCountdown',pro:'YModule <span id=pn>target</span> get_rebootCountdown',cmt:'<p>Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled',ext:''};
doc['Module']['get_serialNumber']={syn:'Returns the serial number of the module, as set by the factory.',lib:'YModule get_serialNumber',pro:'YModule <span id=pn>target</span> get_serialNumber',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory',ext:''};
doc['Module']['get_upTime']={syn:'Returns the number of milliseconds spent since the module was powered on.',lib:'YModule get_upTime',pro:'YModule <span id=pn>target</span> get_upTime',cmt:'<p>Returns the number of milliseconds spent since the module was powered on.</p>',ret:'an integer corresponding to the number of milliseconds spent since the module was powered on',ext:''};
doc['Module']['get_usbCurrent']={syn:'Returns the current consumed by the module on the USB bus, in milli-amps.',lib:'YModule get_usbCurrent',pro:'YModule <span id=pn>target</span> get_usbCurrent',cmt:'<p>Returns the current consumed by the module on the USB bus, in milli-amps.</p>',ret:'an integer corresponding to the current consumed by the module on the USB bus, in milli-amps',ext:''};
doc['Module']['get_userVar']={syn:'Returns the value previously stored in this attribute.',lib:'YModule get_userVar',pro:'YModule <span id=pn>target</span> get_userVar',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',ret:'an integer corresponding to the value previously stored in this attribute',ext:''};
doc['Module']['reboot']={syn:'Schedules a simple module reboot after the given number of seconds.',lib:'YModule reboot',pro:'YModule <span id=pn>target</span> reboot <span id=pn>secBeforeReboot</span>',cmt:'<p>Schedules a simple module reboot after the given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['revertFromFlash']={syn:'Reloads the settings stored in the nonvolatile memory, as when the module is powered on.',lib:'YModule revertFromFlash',pro:'YModule <span id=pn>target</span> revertFromFlash',cmt:'<p>Reloads the settings stored in the nonvolatile memory, as when the module is powered on.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['saveToFlash']={syn:'Saves current settings in the nonvolatile memory of the module.',lib:'YModule saveToFlash',pro:'YModule <span id=pn>target</span> saveToFlash',cmt:'<p>Saves current settings in the nonvolatile memory of the module. Warning: the number of allowed save operations during a module life is limited (about 100000 cycles). Do not call this function within a loop.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['set_allSettings']={syn:'Restores all the settings of the module.',lib:'YModule set_allSettings',pro:'YModule <span id=pn>target</span> set_allSettings <span id=pn>settings</span>',cmt:'<p>Restores all the settings of the module. Useful to restore all the logical names and calibrations parameters of a module from a backup.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['set_beacon']={syn:'Turns on or off the module localization beacon.',lib:'YModule set_beacon',pro:'YModule <span id=pn>target</span> set_beacon <span id=pn>newval</span>',cmt:'<p>Turns on or off the module localization beacon.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Module']['set_logicalName']={syn:'Changes the logical name of the module.',lib:'YModule set_logicalName',pro:'YModule <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the module.</p>',par:{newval:'a string corresponding to the logical name of the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Module']['set_luminosity']={syn:'Changes the luminosity of the module informative leds.',lib:'YModule set_luminosity',pro:'YModule <span id=pn>target</span> set_luminosity <span id=pn>newval</span>',cmt:'<p>Changes the luminosity of the module informative leds. The parameter is a value between 0 and 100.</p>',par:{newval:'an integer corresponding to the luminosity of the module informative leds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Module']['set_userVar']={syn:'Returns the value previously stored in this attribute.',lib:'YModule set_userVar',pro:'YModule <span id=pn>target</span> set_userVar <span id=pn>newval</span>',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Module']['triggerFirmwareUpdate']={syn:'Schedules a module reboot into special firmware update mode.',lib:'YModule triggerFirmwareUpdate',pro:'YModule <span id=pn>target</span> triggerFirmwareUpdate <span id=pn>secBeforeReboot</span>',cmt:'<p>Schedules a module reboot into special firmware update mode.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Module']['updateFirmware']={syn:'Prepares a firmware update of the module.',lib:'YModule updateFirmware',pro:'YModule <span id=pn>target</span> updateFirmware <span id=pn>path</span>',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the byn file to use.'},ret:': A <tt>YFirmwareUpdate</tt> object.'};
//--- (end of generated code: Module)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Humidity function interface',inc:'',cmt:'<p>The Yoctopuce class YHumidity allows you to read and configure Yoctopuce humidity sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Humidity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YHumidity calibrateFromPoints',pro:'YHumidity <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['get_advertisedValue']={syn:'Returns the current value of the humidity sensor (no more than 6 characters).',lib:'YHumidity get_advertisedValue',pro:'YHumidity <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the humidity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the humidity sensor (no more than 6 characters).',ext:''};
doc['Humidity']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.',lib:'YHumidity get_currentRawValue',pro:'YHumidity <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number',ext:''};
doc['Humidity']['get_currentValue']={syn:'Returns the current value of the humidity, in %RH, as a floating point number.',lib:'YHumidity get_currentValue',pro:'YHumidity <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the humidity, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the humidity, in %RH, as a floating point number',ext:''};
doc['Humidity']['get_highestValue']={syn:'Returns the maximal value observed for the humidity since the device was started.',lib:'YHumidity get_highestValue',pro:'YHumidity <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the humidity since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the humidity since the device was started',ext:''};
doc['Humidity']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YHumidity get_logFrequency',pro:'YHumidity <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Humidity']['get_logicalName']={syn:'Returns the logical name of the humidity sensor.',lib:'YHumidity get_logicalName',pro:'YHumidity <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the humidity sensor.</p>',ret:'a string corresponding to the logical name of the humidity sensor.',ext:''};
doc['Humidity']['get_lowestValue']={syn:'Returns the minimal value observed for the humidity since the device was started.',lib:'YHumidity get_lowestValue',pro:'YHumidity <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the humidity since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the humidity since the device was started',ext:''};
doc['Humidity']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YHumidity get_recordedData',pro:'YHumidity <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Humidity']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YHumidity get_reportFrequency',pro:'YHumidity <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Humidity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YHumidity get_resolution',pro:'YHumidity <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Humidity']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YHumidity get_sensorState',pro:'YHumidity <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Humidity']['get_unit']={syn:'Returns the measuring unit for the humidity.',lib:'YHumidity get_unit',pro:'YHumidity <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the humidity.</p>',ret:'a string corresponding to the measuring unit for the humidity',ext:''};
doc['Humidity']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YHumidity isSensorReady',pro:'YHumidity <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Humidity']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YHumidity loadCalibrationPoints',pro:'YHumidity <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YHumidity set_highestValue',pro:'YHumidity <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YHumidity set_logFrequency',pro:'YHumidity <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_logicalName']={syn:'Changes the logical name of the humidity sensor.',lib:'YHumidity set_logicalName',pro:'YHumidity <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the humidity sensor.</p>',par:{newval:'a string corresponding to the logical name of the humidity sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YHumidity set_lowestValue',pro:'YHumidity <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YHumidity set_reportFrequency',pro:'YHumidity <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YHumidity set_resolution',pro:'YHumidity <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Humidity']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YHumidity startDataLogger',pro:'YHumidity <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Humidity']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YHumidity stopDataLogger',pro:'YHumidity <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Humidity)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Pressure function interface',inc:'',cmt:'<p>The Yoctopuce class YPressure allows you to read and configure Yoctopuce pressure sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Pressure']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YPressure calibrateFromPoints',pro:'YPressure <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['get_advertisedValue']={syn:'Returns the current value of the pressure sensor (no more than 6 characters).',lib:'YPressure get_advertisedValue',pro:'YPressure <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the pressure sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the pressure sensor (no more than 6 characters).',ext:''};
doc['Pressure']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.',lib:'YPressure get_currentRawValue',pro:'YPressure <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number',ext:''};
doc['Pressure']['get_currentValue']={syn:'Returns the current value of the pressure, in millibar (hPa), as a floating point number.',lib:'YPressure get_currentValue',pro:'YPressure <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the pressure, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the pressure, in millibar (hPa), as a floating point number',ext:''};
doc['Pressure']['get_highestValue']={syn:'Returns the maximal value observed for the pressure since the device was started.',lib:'YPressure get_highestValue',pro:'YPressure <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the pressure since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the pressure since the device was started',ext:''};
doc['Pressure']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YPressure get_logFrequency',pro:'YPressure <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Pressure']['get_logicalName']={syn:'Returns the logical name of the pressure sensor.',lib:'YPressure get_logicalName',pro:'YPressure <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the pressure sensor.</p>',ret:'a string corresponding to the logical name of the pressure sensor.',ext:''};
doc['Pressure']['get_lowestValue']={syn:'Returns the minimal value observed for the pressure since the device was started.',lib:'YPressure get_lowestValue',pro:'YPressure <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the pressure since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the pressure since the device was started',ext:''};
doc['Pressure']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YPressure get_recordedData',pro:'YPressure <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Pressure']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YPressure get_reportFrequency',pro:'YPressure <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Pressure']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YPressure get_resolution',pro:'YPressure <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Pressure']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YPressure get_sensorState',pro:'YPressure <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Pressure']['get_unit']={syn:'Returns the measuring unit for the pressure.',lib:'YPressure get_unit',pro:'YPressure <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the pressure.</p>',ret:'a string corresponding to the measuring unit for the pressure',ext:''};
doc['Pressure']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YPressure isSensorReady',pro:'YPressure <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Pressure']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YPressure loadCalibrationPoints',pro:'YPressure <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YPressure set_highestValue',pro:'YPressure <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YPressure set_logFrequency',pro:'YPressure <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_logicalName']={syn:'Changes the logical name of the pressure sensor.',lib:'YPressure set_logicalName',pro:'YPressure <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the pressure sensor.</p>',par:{newval:'a string corresponding to the logical name of the pressure sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YPressure set_lowestValue',pro:'YPressure <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YPressure set_reportFrequency',pro:'YPressure <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YPressure set_resolution',pro:'YPressure <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Pressure']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YPressure startDataLogger',pro:'YPressure <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Pressure']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YPressure stopDataLogger',pro:'YPressure <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Pressure)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Temperature function interface',inc:'',cmt:'<p>The Yoctopuce class YTemperature allows you to read and configure Yoctopuce temperature sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to configure some specific parameters for some sensors (connection type, temperature mapping table).</p>'}};
doc['Temperature']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YTemperature calibrateFromPoints',pro:'YTemperature <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['get_advertisedValue']={syn:'Returns the current value of the temperature sensor (no more than 6 characters).',lib:'YTemperature get_advertisedValue',pro:'YTemperature <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the temperature sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the temperature sensor (no more than 6 characters).',ext:''};
doc['Temperature']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.',lib:'YTemperature get_currentRawValue',pro:'YTemperature <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number',ext:''};
doc['Temperature']['get_currentValue']={syn:'Returns the current value of the temperature, in Celsius, as a floating point number.',lib:'YTemperature get_currentValue',pro:'YTemperature <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the temperature, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the temperature, in Celsius, as a floating point number',ext:''};
doc['Temperature']['get_highestValue']={syn:'Returns the maximal value observed for the temperature since the device was started.',lib:'YTemperature get_highestValue',pro:'YTemperature <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the temperature since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the temperature since the device was started',ext:''};
doc['Temperature']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YTemperature get_logFrequency',pro:'YTemperature <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Temperature']['get_logicalName']={syn:'Returns the logical name of the temperature sensor.',lib:'YTemperature get_logicalName',pro:'YTemperature <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the temperature sensor.</p>',ret:'a string corresponding to the logical name of the temperature sensor.',ext:''};
doc['Temperature']['get_lowestValue']={syn:'Returns the minimal value observed for the temperature since the device was started.',lib:'YTemperature get_lowestValue',pro:'YTemperature <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the temperature since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the temperature since the device was started',ext:''};
doc['Temperature']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YTemperature get_recordedData',pro:'YTemperature <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Temperature']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YTemperature get_reportFrequency',pro:'YTemperature <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Temperature']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YTemperature get_resolution',pro:'YTemperature <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Temperature']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YTemperature get_sensorState',pro:'YTemperature <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Temperature']['get_sensorType']={syn:'Returns the temperature sensor type.',lib:'YTemperature get_sensorType',pro:'YTemperature <span id=pn>target</span> get_sensorType',cmt:'<p>Returns the temperature sensor type.</p>',ret:'a value among <tt>DIGITAL</tt>, <tt>TYPE_K</tt>, <tt>TYPE_E</tt>, <tt>TYPE_J</tt>, <tt>TYPE_N</tt>, <tt>TYPE_R</tt>, <tt>TYPE_S</tt>, <tt>TYPE_T</tt>, <tt>PT100_4WIRES</tt>, <tt>PT100_3WIRES</tt>, <tt>PT100_2WIRES</tt>, <tt>RES_OHM</tt>, <tt>RES_NTC</tt> and <tt>RES_LINEAR</tt> corresponding to the temperature sensor type',ext:''};
doc['Temperature']['get_unit']={syn:'Returns the measuring unit for the temperature.',lib:'YTemperature get_unit',pro:'YTemperature <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the temperature.</p>',ret:'a string corresponding to the measuring unit for the temperature',ext:''};
doc['Temperature']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YTemperature isSensorReady',pro:'YTemperature <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Temperature']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YTemperature loadCalibrationPoints',pro:'YTemperature <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['loadThermistorResponseTable']={syn:'Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function.',lib:'YTemperature loadThermistorResponseTable',pro:'YTemperature <span id=pn>target</span> loadThermistorResponseTable <span id=pn>tempValues</span> <span id=pn>resValues</span>',cmt:'<p>Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperatures (in degrees Celcius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, that is filled by the function with the value (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YTemperature set_highestValue',pro:'YTemperature <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YTemperature set_logFrequency',pro:'YTemperature <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_logicalName']={syn:'Changes the logical name of the temperature sensor.',lib:'YTemperature set_logicalName',pro:'YTemperature <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the temperature sensor.</p>',par:{newval:'a string corresponding to the logical name of the temperature sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YTemperature set_lowestValue',pro:'YTemperature <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_ntcParameters']={syn:'Configure NTC thermistor parameters in order to properly compute the temperature from the measured resistance.',lib:'YTemperature set_ntcParameters',pro:'YTemperature <span id=pn>target</span> set_ntcParameters <span id=pn>res25</span> <span id=pn>beta</span>',cmt:'<p>Configure NTC thermistor parameters in order to properly compute the temperature from the measured resistance. For increased precision, you can enter a complete mapping table using set_thermistorResponseTable. This function can only be used with a temperature sensor based on thermistors.</p>',par:{res25:'thermistor resistance at 25 degrees Celsius',beta:'Beta value'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YTemperature set_reportFrequency',pro:'YTemperature <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YTemperature set_resolution',pro:'YTemperature <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_sensorType']={syn:'Modifies the temperature sensor type.',lib:'YTemperature set_sensorType',pro:'YTemperature <span id=pn>target</span> set_sensorType <span id=pn>newval</span>',cmt:'<p>Modifies the temperature sensor type. This function is used to define the type of thermocouple (K,E...) used with the device. It has no effect if module is using a digital sensor or a thermistor.</p>',par:{newval:'a value among <tt>DIGITAL</tt>, <tt>TYPE_K</tt>, <tt>TYPE_E</tt>, <tt>TYPE_J</tt>, <tt>TYPE_N</tt>, <tt>TYPE_R</tt>, <tt>TYPE_S</tt>, <tt>TYPE_T</tt>, <tt>PT100_4WIRES</tt>, <tt>PT100_3WIRES</tt>, <tt>PT100_2WIRES</tt>, <tt>RES_OHM</tt>, <tt>RES_NTC</tt> and <tt>RES_LINEAR</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_thermistorResponseTable']={syn:'Records a thermistor response table, in order to interpolate the temperature from the measured resistance.',lib:'YTemperature set_thermistorResponseTable',pro:'YTemperature <span id=pn>target</span> set_thermistorResponseTable <span id=pn>tempValues</span> <span id=pn>resValues</span>',cmt:'<p>Records a thermistor response table, in order to interpolate the temperature from the measured resistance. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, corresponding to all temperatures (in degrees Celcius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, corresponding to the resistance values (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['set_unit']={syn:'Changes the measuring unit for the measured temperature.',lib:'YTemperature set_unit',pro:'YTemperature <span id=pn>target</span> set_unit <span id=pn>newval</span>',cmt:'<p>Changes the measuring unit for the measured temperature. That unit is a string. If that strings end with the letter F all temperatures values will returned in Fahrenheit degrees. If that String ends with the letter K all values will be returned in Kelvin degrees. If that String ends with the letter C all values will be returned in Celsius degrees. If the string ends with any other character the change will be ignored. WARNING: if a specific calibration is defined for the temperature function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured temperature'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Temperature']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YTemperature startDataLogger',pro:'YTemperature <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Temperature']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YTemperature stopDataLogger',pro:'YTemperature <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'DataLogger function interface',inc:'',cmt:'<p>Yoctopuce sensors include a non-volatile memory capable of storing ongoing measured data automatically, without requiring a permanent connection to a computer. The DataLogger function controls the global parameters of the internal data logger.</p>'}};
doc['DataLogger']['forgetAllDataStreams']={syn:'Clears the data logger memory and discards all recorded data streams.',lib:'YDataLogger forgetAllDataStreams',pro:'YDataLogger <span id=pn>target</span> forgetAllDataStreams',cmt:'<p>Clears the data logger memory and discards all recorded data streams. This method also resets the current run index to zero.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['get_advertisedValue']={syn:'Returns the current value of the data logger (no more than 6 characters).',lib:'YDataLogger get_advertisedValue',pro:'YDataLogger <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the data logger (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the data logger (no more than 6 characters).',ext:''};
doc['DataLogger']['get_autoStart']={syn:'Returns the default activation state of the data logger on power up.',lib:'YDataLogger get_autoStart',pro:'YDataLogger <span id=pn>target</span> get_autoStart',cmt:'<p>Returns the default activation state of the data logger on power up.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the default activation state of the data logger on power up',ext:''};
doc['DataLogger']['get_beaconDriven']={syn:'Return true if the data logger is synchronised with the localization beacon.',lib:'YDataLogger get_beaconDriven',pro:'YDataLogger <span id=pn>target</span> get_beaconDriven',cmt:'<p>Return true if the data logger is synchronised with the localization beacon.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>',ext:''};
doc['DataLogger']['get_currentRunIndex']={syn:'Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.',lib:'YDataLogger get_currentRunIndex',pro:'YDataLogger <span id=pn>target</span> get_currentRunIndex',cmt:'<p>Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.</p>',ret:'an integer corresponding to the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point',ext:''};
doc['DataLogger']['get_dataSets']={syn:'Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.',lib:'YDataLogger get_dataSets',pro:'YDataLogger <span id=pn>target</span> get_dataSets',cmt:'<p>Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.</p><p> This function only works if the device uses a recent firmware, as YDataSet objects are not supported by firmwares older than version 13000.</p>',ret:'a list of YDataSet object.',ext:''};
doc['DataLogger']['get_logicalName']={syn:'Returns the logical name of the data logger.',lib:'YDataLogger get_logicalName',pro:'YDataLogger <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the data logger.</p>',ret:'a string corresponding to the logical name of the data logger.',ext:''};
doc['DataLogger']['get_recording']={syn:'Returns the current activation state of the data logger.',lib:'YDataLogger get_recording',pro:'YDataLogger <span id=pn>target</span> get_recording',cmt:'<p>Returns the current activation state of the data logger.</p>',ret:'a value among <tt>OFF</tt>, <tt>ON</tt> and <tt>PENDING</tt> corresponding to the current activation state of the data logger',ext:''};
doc['DataLogger']['get_timeUTC']={syn:'Returns the Unix timestamp for current UTC time, if known.',lib:'YDataLogger get_timeUTC',pro:'YDataLogger <span id=pn>target</span> get_timeUTC',cmt:'<p>Returns the Unix timestamp for current UTC time, if known.</p>',ret:'an integer corresponding to the Unix timestamp for current UTC time, if known',ext:''};
doc['DataLogger']['set_autoStart']={syn:'Changes the default activation state of the data logger on power up.',lib:'YDataLogger set_autoStart',pro:'YDataLogger <span id=pn>target</span> set_autoStart <span id=pn>newval</span>',cmt:'<p>Changes the default activation state of the data logger on power up.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the default activation state of the data logger on power up'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['set_beaconDriven']={syn:'Changes the type of synchronisation of the data logger.',lib:'YDataLogger set_beaconDriven',pro:'YDataLogger <span id=pn>target</span> set_beaconDriven <span id=pn>newval</span>',cmt:'<p>Changes the type of synchronisation of the data logger.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the type of synchronisation of the data logger'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['set_logicalName']={syn:'Changes the logical name of the data logger.',lib:'YDataLogger set_logicalName',pro:'YDataLogger <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the data logger.</p>',par:{newval:'a string corresponding to the logical name of the data logger.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['set_recording']={syn:'Changes the activation state of the data logger to start/stop recording data.',lib:'YDataLogger set_recording',pro:'YDataLogger <span id=pn>target</span> set_recording <span id=pn>newval</span>',cmt:'<p>Changes the activation state of the data logger to start/stop recording data.</p>',par:{newval:'a value among <tt>OFF</tt>, <tt>ON</tt> and <tt>PENDING</tt> corresponding to the activation state of the data logger to start/stop recording data'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DataLogger']['set_timeUTC']={syn:'Changes the current UTC time reference used for recorded data.',lib:'YDataLogger set_timeUTC',pro:'YDataLogger <span id=pn>target</span> set_timeUTC <span id=pn>newval</span>',cmt:'<p>Changes the current UTC time reference used for recorded data.</p>',par:{newval:'an integer corresponding to the current UTC time reference used for recorded data'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: DataLogger)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'DisplayLayer object interface',inc:'',cmt:'<p>A DisplayLayer is an image layer containing objects to display (bitmaps, text, etc.). The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>'}};
doc['DisplayLayer']['clear']={syn:'Erases the whole content of the layer (makes it fully transparent).',lib:'YDisplayLayer clear',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] clear',cmt:'<p>Erases the whole content of the layer (makes it fully transparent). This method does not change any other attribute of the layer. To reinitialize the layer attributes to defaults settings, use the method <tt>reset()</tt> instead.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['clearConsole']={syn:'Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.',lib:'YDisplayLayer clearConsole',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] clearConsole',cmt:'<p>Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['consoleOut']={syn:'Outputs a message in the console area, and advances the console pointer accordingly.',lib:'YDisplayLayer consoleOut',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] consoleOut <span id=pn>text</span>',cmt:'<p>Outputs a message in the console area, and advances the console pointer accordingly. The console pointer position is automatically moved to the beginning of the next line when a newline character is met, or when the right margin is hit. When the new text to display extends below the lower margin, the console area is automatically scrolled up.</p>',par:{text:'the message to display'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawBar']={syn:'Draws a filled rectangular bar at a specified position.',lib:'YDisplayLayer drawBar',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawBar <span id=pn>x1</span> <span id=pn>y1</span> <span id=pn>x2</span> <span id=pn>y2</span>',cmt:'<p>Draws a filled rectangular bar at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawBitmap']={syn:'Draws a bitmap at the specified position.',lib:'YDisplayLayer drawBitmap',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawBitmap <span id=pn>x</span> <span id=pn>y</span> <span id=pn>w</span> <span id=pn>bitmap</span> <span id=pn>bgcol</span>',cmt:'<p>Draws a bitmap at the specified position. The bitmap is provided as a binary object, where each pixel maps to a bit, from left to right and from top to bottom. The most significant bit of each byte maps to the leftmost pixel, and the least significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the layer selected pen color. Bits set to 0 are drawn using the specified background gray level, unless -1 is specified, in which case they are not drawn at all (as if transparent).</p>',par:{x:'the distance from left of layer to the left of the bitmap, in pixels',y:'the distance from top of layer to the top of the bitmap, in pixels',w:'the width of the bitmap, in pixels',bitmap:'a binary object',bgcol:'the background gray level to use for zero bits (0 = black, 255 = white), or -1 to leave the pixels unchanged'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawCircle']={syn:'Draws an empty circle at a specified position.',lib:'YDisplayLayer drawCircle',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawCircle <span id=pn>x</span> <span id=pn>y</span> <span id=pn>r</span>',cmt:'<p>Draws an empty circle at a specified position.</p>',par:{x:'the distance from left of layer to the center of the circle, in pixels',y:'the distance from top of layer to the center of the circle, in pixels',r:'the radius of the circle, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawDisc']={syn:'Draws a filled disc at a given position.',lib:'YDisplayLayer drawDisc',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawDisc <span id=pn>x</span> <span id=pn>y</span> <span id=pn>r</span>',cmt:'<p>Draws a filled disc at a given position.</p>',par:{x:'the distance from left of layer to the center of the disc, in pixels',y:'the distance from top of layer to the center of the disc, in pixels',r:'the radius of the disc, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawImage']={syn:'Draws a GIF image at the specified position.',lib:'YDisplayLayer drawImage',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawImage <span id=pn>x</span> <span id=pn>y</span> <span id=pn>imagename</span>',cmt:'<p>Draws a GIF image at the specified position. The GIF image must have been previously uploaded to the device built-in memory. If you experience problems using an image file, check the device logs for any error message such as missing image file or bad image file format.</p>',par:{x:'the distance from left of layer to the left of the image, in pixels',y:'the distance from top of layer to the top of the image, in pixels',imagename:'the GIF file name'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawPixel']={syn:'Draws a single pixel at the specified position.',lib:'YDisplayLayer drawPixel',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawPixel <span id=pn>x</span> <span id=pn>y</span>',cmt:'<p>Draws a single pixel at the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawRect']={syn:'Draws an empty rectangle at a specified position.',lib:'YDisplayLayer drawRect',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawRect <span id=pn>x1</span> <span id=pn>y1</span> <span id=pn>x2</span> <span id=pn>y2</span>',cmt:'<p>Draws an empty rectangle at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['drawText']={syn:'Draws a text string at the specified position.',lib:'YDisplayLayer drawText',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] drawText <span id=pn>x</span> <span id=pn>y</span> <span id=pn>anchor</span> <span id=pn>text</span>',cmt:'<p>Draws a text string at the specified position. The point of the text that is aligned to the specified pixel position is called the anchor point, and can be chosen among several options. Text is rendered from left to right, without implicit wrapping.</p>',par:{x:'the distance from left of layer to the text anchor point, in pixels',y:'the distance from top of layer to the text anchor point, in pixels',anchor:'the text anchor point, chosen among the <tt>Y_ALIGN</tt> enumeration: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'the text string to draw'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'YDisplayLayer get_displayHeight',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] get_displayHeight',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels On failure, throws an exception or returns INVALID.'};
doc['DisplayLayer']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'YDisplayLayer get_displayWidth',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] get_displayWidth',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels On failure, throws an exception or returns INVALID.'};
doc['DisplayLayer']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'YDisplayLayer get_layerHeight',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] get_layerHeight',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:''};
doc['DisplayLayer']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'YDisplayLayer get_layerWidth',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] get_layerWidth',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:''};
doc['DisplayLayer']['hide']={syn:'Hides the layer.',lib:'YDisplayLayer hide',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] hide',cmt:'<p>Hides the layer. The state of the layer is perserved but the layer is not displayed on the screen until the next call to <tt>unhide()</tt>. Hiding the layer can positively affect the drawing speed, since it postpones the rendering until all operations are completed (double-buffering).</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['lineTo']={syn:'Draws a line from current drawing pointer position to the specified position.',lib:'YDisplayLayer lineTo',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] lineTo <span id=pn>x</span> <span id=pn>y</span>',cmt:'<p>Draws a line from current drawing pointer position to the specified position. The specified destination pixel is included in the line. The pointer position is then moved to the end point of the line.</p>',par:{x:'the distance from left of layer to the end point of the line, in pixels',y:'the distance from top of layer to the end point of the line, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['moveTo']={syn:'Moves the drawing pointer of this layer to the specified position.',lib:'YDisplayLayer moveTo',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] moveTo <span id=pn>x</span> <span id=pn>y</span>',cmt:'<p>Moves the drawing pointer of this layer to the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['reset']={syn:'Reverts the layer to its initial state (fully transparent, default settings).',lib:'YDisplayLayer reset',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] reset',cmt:'<p>Reverts the layer to its initial state (fully transparent, default settings). Reinitializes the drawing pointer to the upper left position, and selects the most visible pen color. If you only want to erase the layer content, use the method <tt>clear()</tt> instead.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['selectColorPen']={syn:'Selects the pen color for all subsequent drawing functions, including text drawing.',lib:'YDisplayLayer selectColorPen',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] selectColorPen <span id=pn>color</span>',cmt:'<p>Selects the pen color for all subsequent drawing functions, including text drawing. The pen color is provided as an RGB value. For grayscale or monochrome displays, the value is automatically converted to the proper range.</p>',par:{color:'the desired pen color, as a 24-bit RGB value'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['selectEraser']={syn:'Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions.',lib:'YDisplayLayer selectEraser',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] selectEraser',cmt:'<p>Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions. Any point drawn using the eraser becomes transparent (as when the layer is empty), showing the other layers beneath it.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['selectFont']={syn:'Selects a font to use for the next text drawing functions, by providing the name of the font file.',lib:'YDisplayLayer selectFont',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] selectFont <span id=pn>fontname</span>',cmt:'<p>Selects a font to use for the next text drawing functions, by providing the name of the font file. You can use a built-in font as well as a font file that you have previously uploaded to the device built-in memory. If you experience problems selecting a font file, check the device logs for any error message such as missing font file or bad font file format.</p>',par:{fontname:'the font file name'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['selectGrayPen']={syn:'Selects the pen gray level for all subsequent drawing functions, including text drawing.',lib:'YDisplayLayer selectGrayPen',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] selectGrayPen <span id=pn>graylevel</span>',cmt:'<p>Selects the pen gray level for all subsequent drawing functions, including text drawing. The gray level is provided as a number between 0 (black) and 255 (white, or whichever the lighest color is). For monochrome displays (without gray levels), any value lower than 128 is rendered as black, and any value equal or above to 128 is non-black.</p>',par:{graylevel:'the desired gray level, from 0 to 255'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Enables or disables anti-aliasing for drawing oblique lines and circles.',lib:'YDisplayLayer setAntialiasingMode',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setAntialiasingMode <span id=pn>mode</span>',cmt:'<p>Enables or disables anti-aliasing for drawing oblique lines and circles. Anti-aliasing provides a smoother aspect when looked from far enough, but it can add fuzzyness when the display is looked from very close. At the end of the day, it is your personal choice. Anti-aliasing is enabled by default on grayscale and color displays, but you can disable it if you prefer. This setting has no effect on monochrome displays.</p>',par:{mode:'<t>true</t> to enable antialiasing, <t>false</t> to disable it.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setConsoleBackground']={syn:'Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.',lib:'YDisplayLayer setConsoleBackground',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setConsoleBackground <span id=pn>bgcol</span>',cmt:'<p>Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.</p>',par:{bgcol:'the background gray level to use when scrolling (0 = black, 255 = white), or -1 for transparent'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setConsoleMargins']={syn:'Sets up display margins for the <tt>consoleOut</tt> function.',lib:'YDisplayLayer setConsoleMargins',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setConsoleMargins <span id=pn>x1</span> <span id=pn>y1</span> <span id=pn>x2</span> <span id=pn>y2</span>',cmt:'<p>Sets up display margins for the <tt>consoleOut</tt> function.</p>',par:{x1:'the distance from left of layer to the left margin, in pixels',y1:'the distance from top of layer to the top margin, in pixels',x2:'the distance from left of layer to the right margin, in pixels',y2:'the distance from top of layer to the bottom margin, in pixels'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.',lib:'YDisplayLayer setConsoleWordWrap',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setConsoleWordWrap <span id=pn>wordwrap</span>',cmt:'<p>Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.</p>',par:{wordwrap:'<tt>true</tt> to wrap only between words, <tt>false</tt> to wrap on the last column anyway.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['setLayerPosition']={syn:'Sets the position of the layer relative to the display upper left corner.',lib:'YDisplayLayer setLayerPosition',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] setLayerPosition <span id=pn>x</span> <span id=pn>y</span> <span id=pn>scrollTime</span>',cmt:'<p>Sets the position of the layer relative to the display upper left corner. When smooth scrolling is used, the display offset of the layer is automatically updated during the next milliseconds to animate the move of the layer.</p>',par:{x:'the distance from left of display to the upper left corner of the layer',y:'the distance from top of display to the upper left corner of the layer',scrollTime:'number of milliseconds to use for smooth scrolling, or 0 if the scrolling should be immediate.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DisplayLayer']['unhide']={syn:'Shows the layer.',lib:'YDisplayLayer unhide',pro:'YDisplay <span id=pn>target</span> [-layer <span id=pn>layerId</span>] unhide',cmt:'<p>Shows the layer. Shows the layer again after a hide command.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: DisplayLayer)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'AnButton function interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to measure the state of a simple button as well as to read an analog potentiometer (variable resistance). This can be use for instance with a continuous rotating knob, a throttle grip or a joystick. The module is capable to calibrate itself on min and max values, in order to compute a calibrated value that varies proportionally with the potentiometer position, regardless of its total resistance.</p>'}};
doc['AnButton']['get_advertisedValue']={syn:'Returns the current value of the analog input (no more than 6 characters).',lib:'YAnButton get_advertisedValue',pro:'YAnButton <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the analog input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the analog input (no more than 6 characters).',ext:''};
doc['AnButton']['get_analogCalibration']={syn:'Tells if a calibration process is currently ongoing.',lib:'YAnButton get_analogCalibration',pro:'YAnButton <span id=pn>target</span> get_analogCalibration',cmt:'<p>Tells if a calibration process is currently ongoing.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>',ext:''};
doc['AnButton']['get_calibratedValue']={syn:'Returns the current calibrated input value (between 0 and 1000, included).',lib:'YAnButton get_calibratedValue',pro:'YAnButton <span id=pn>target</span> get_calibratedValue',cmt:'<p>Returns the current calibrated input value (between 0 and 1000, included).</p>',ret:'an integer corresponding to the current calibrated input value (between 0 and 1000, included)',ext:''};
doc['AnButton']['get_calibrationMax']={syn:'Returns the maximal value measured during the calibration (between 0 and 4095, included).',lib:'YAnButton get_calibrationMax',pro:'YAnButton <span id=pn>target</span> get_calibrationMax',cmt:'<p>Returns the maximal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the maximal value measured during the calibration (between 0 and 4095, included)',ext:''};
doc['AnButton']['get_calibrationMin']={syn:'Returns the minimal value measured during the calibration (between 0 and 4095, included).',lib:'YAnButton get_calibrationMin',pro:'YAnButton <span id=pn>target</span> get_calibrationMin',cmt:'<p>Returns the minimal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the minimal value measured during the calibration (between 0 and 4095, included)',ext:''};
doc['AnButton']['get_isPressed']={syn:'Returns true if the input (considered as binary) is active (closed contact), and false otherwise.',lib:'YAnButton get_isPressed',pro:'YAnButton <span id=pn>target</span> get_isPressed',cmt:'<p>Returns true if the input (considered as binary) is active (closed contact), and false otherwise.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the input (considered as binary) is active (closed contact), and false otherwise',ext:''};
doc['AnButton']['get_lastTimePressed']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).',lib:'YAnButton get_lastTimePressed',pro:'YAnButton <span id=pn>target</span> get_lastTimePressed',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed)',ext:''};
doc['AnButton']['get_lastTimeReleased']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).',lib:'YAnButton get_lastTimeReleased',pro:'YAnButton <span id=pn>target</span> get_lastTimeReleased',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open)',ext:''};
doc['AnButton']['get_logicalName']={syn:'Returns the logical name of the analog input.',lib:'YAnButton get_logicalName',pro:'YAnButton <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the analog input.</p>',ret:'a string corresponding to the logical name of the analog input.',ext:''};
doc['AnButton']['get_rawValue']={syn:'Returns the current measured input value as-is (between 0 and 4095, included).',lib:'YAnButton get_rawValue',pro:'YAnButton <span id=pn>target</span> get_rawValue',cmt:'<p>Returns the current measured input value as-is (between 0 and 4095, included).</p>',ret:'an integer corresponding to the current measured input value as-is (between 0 and 4095, included)',ext:''};
doc['AnButton']['get_sensitivity']={syn:'Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'YAnButton get_sensitivity',pro:'YAnButton <span id=pn>target</span> get_sensitivity',cmt:'<p>Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.</p>',ret:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks',ext:''};
doc['AnButton']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'YAnButton resetCounter',pro:'YAnButton <span id=pn>target</span> resetCounter',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_analogCalibration']={syn:'Starts or stops the calibration process.',lib:'YAnButton set_analogCalibration',pro:'YAnButton <span id=pn>target</span> set_analogCalibration <span id=pn>newval</span>',cmt:'<p>Starts or stops the calibration process.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_calibrationMax']={syn:'Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'YAnButton set_calibrationMax',pro:'YAnButton <span id=pn>target</span> set_calibrationMax <span id=pn>newval</span>',cmt:'<p>Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.</p>',par:{newval:'an integer corresponding to the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_calibrationMin']={syn:'Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'YAnButton set_calibrationMin',pro:'YAnButton <span id=pn>target</span> set_calibrationMin <span id=pn>newval</span>',cmt:'<p>Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.</p>',par:{newval:'an integer corresponding to the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_logicalName']={syn:'Changes the logical name of the analog input.',lib:'YAnButton set_logicalName',pro:'YAnButton <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the analog input.</p>',par:{newval:'a string corresponding to the logical name of the analog input.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AnButton']['set_sensitivity']={syn:'Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'YAnButton set_sensitivity',pro:'YAnButton <span id=pn>target</span> set_sensitivity <span id=pn>newval</span>',cmt:'<p>Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks. The sensibility is used to filter variations around a fixed value, but does not preclude the transmission of events when the input value evolves constantly in the same direction. Special case: when the value 1000 is used, the callback will only be thrown when the logical state of the input switches from pressed to released and back.</p>',par:{newval:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: AnButton)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'CarbonDioxide function interface',inc:'',cmt:'<p>The Yoctopuce class YCarbonDioxide allows you to read and configure Yoctopuce CO2 sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to perform manual calibration if reuired.</p>'}};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YCarbonDioxide calibrateFromPoints',pro:'YCarbonDioxide <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['get_abcPeriod']={syn:'Returns the Automatic Baseline Calibration period, in hours.',lib:'YCarbonDioxide get_abcPeriod',pro:'YCarbonDioxide <span id=pn>target</span> get_abcPeriod',cmt:'<p>Returns the Automatic Baseline Calibration period, in hours. A negative value means that automatic baseline calibration is disabled.</p>',ret:'an integer corresponding to the Automatic Baseline Calibration period, in hours',ext:''};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Returns the current value of the CO2 sensor (no more than 6 characters).',lib:'YCarbonDioxide get_advertisedValue',pro:'YCarbonDioxide <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the CO2 sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the CO2 sensor (no more than 6 characters).',ext:''};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'YCarbonDioxide get_currentRawValue',pro:'YCarbonDioxide <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:''};
doc['CarbonDioxide']['get_currentValue']={syn:'Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.',lib:'YCarbonDioxide get_currentValue',pro:'YCarbonDioxide <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the CO2 concentration, in ppm (vol), as a floating point number',ext:''};
doc['CarbonDioxide']['get_highestValue']={syn:'Returns the maximal value observed for the CO2 concentration since the device was started.',lib:'YCarbonDioxide get_highestValue',pro:'YCarbonDioxide <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the CO2 concentration since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the CO2 concentration since the device was started',ext:''};
doc['CarbonDioxide']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YCarbonDioxide get_logFrequency',pro:'YCarbonDioxide <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['CarbonDioxide']['get_logicalName']={syn:'Returns the logical name of the CO2 sensor.',lib:'YCarbonDioxide get_logicalName',pro:'YCarbonDioxide <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the CO2 sensor.</p>',ret:'a string corresponding to the logical name of the CO2 sensor.',ext:''};
doc['CarbonDioxide']['get_lowestValue']={syn:'Returns the minimal value observed for the CO2 concentration since the device was started.',lib:'YCarbonDioxide get_lowestValue',pro:'YCarbonDioxide <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the CO2 concentration since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the CO2 concentration since the device was started',ext:''};
doc['CarbonDioxide']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YCarbonDioxide get_recordedData',pro:'YCarbonDioxide <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['CarbonDioxide']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YCarbonDioxide get_reportFrequency',pro:'YCarbonDioxide <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['CarbonDioxide']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YCarbonDioxide get_resolution',pro:'YCarbonDioxide <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['CarbonDioxide']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YCarbonDioxide get_sensorState',pro:'YCarbonDioxide <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['CarbonDioxide']['get_unit']={syn:'Returns the measuring unit for the CO2 concentration.',lib:'YCarbonDioxide get_unit',pro:'YCarbonDioxide <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the CO2 concentration.</p>',ret:'a string corresponding to the measuring unit for the CO2 concentration',ext:''};
doc['CarbonDioxide']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YCarbonDioxide isSensorReady',pro:'YCarbonDioxide <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['CarbonDioxide']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YCarbonDioxide loadCalibrationPoints',pro:'YCarbonDioxide <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_abcPeriod']={syn:'Modifies Automatic Baseline Calibration period, in hours.',lib:'YCarbonDioxide set_abcPeriod',pro:'YCarbonDioxide <span id=pn>target</span> set_abcPeriod <span id=pn>newval</span>',cmt:'<p>Modifies Automatic Baseline Calibration period, in hours. If you need to disable automatic baseline calibration (for instance when using the sensor in an environment that is constantly above 400ppm CO2), set the period to -1.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YCarbonDioxide set_highestValue',pro:'YCarbonDioxide <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YCarbonDioxide set_logFrequency',pro:'YCarbonDioxide <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_logicalName']={syn:'Changes the logical name of the CO2 sensor.',lib:'YCarbonDioxide set_logicalName',pro:'YCarbonDioxide <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the CO2 sensor.</p>',par:{newval:'a string corresponding to the logical name of the CO2 sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YCarbonDioxide set_lowestValue',pro:'YCarbonDioxide <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YCarbonDioxide set_reportFrequency',pro:'YCarbonDioxide <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YCarbonDioxide set_resolution',pro:'YCarbonDioxide <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YCarbonDioxide startDataLogger',pro:'YCarbonDioxide <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['CarbonDioxide']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YCarbonDioxide stopDataLogger',pro:'YCarbonDioxide <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['CarbonDioxide']['triggetBaselineCalibration']={syn:'Triggers a baseline calibration at standard CO2 ambiant level (400ppm).',lib:'YCarbonDioxide triggetBaselineCalibration',pro:'YCarbonDioxide <span id=pn>target</span> triggetBaselineCalibration',cmt:'<p>Triggers a baseline calibration at standard CO2 ambiant level (400ppm). It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a baseline calibration, make sure to put the sensor in a standard environment (e.g. outside in fresh air) at around 400ppm.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['CarbonDioxide']['triggetZeroCalibration']={syn:'Triggers a zero calibration of the sensor on carbon dioxide-free air.',lib:'YCarbonDioxide triggetZeroCalibration',pro:'YCarbonDioxide <span id=pn>target</span> triggetZeroCalibration',cmt:'<p>Triggers a zero calibration of the sensor on carbon dioxide-free air. It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a zero calibration, you should circulate carbon dioxide-free air within the sensor for a minute or two, using a small pipe connected to the sensor. Please contact support@yoctopuce.com for more details on the zero calibration procedure.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'ColorLed function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to drive a color led using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a led with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLed']['addHslMoveToBlinkSeq']={syn:'Add a new transition to the blinking sequence, the move will be performed in the HSL space.',lib:'YColorLed addHslMoveToBlinkSeq',pro:'YColorLed <span id=pn>target</span> addHslMoveToBlinkSeq <span id=pn>HSLcolor</span> <span id=pn>msDelay</span>',cmt:'<p>Add a new transition to the blinking sequence, the move will be performed in the HSL space.</p>',par:{HSLcolor:'desired HSL color when the traisntion is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['addRgbMoveToBlinkSeq']={syn:'Add a new transition to the blinking sequence, the move will be performed in the RGB space.',lib:'YColorLed addRgbMoveToBlinkSeq',pro:'YColorLed <span id=pn>target</span> addRgbMoveToBlinkSeq <span id=pn>RGBcolor</span> <span id=pn>msDelay</span>',cmt:'<p>Add a new transition to the blinking sequence, the move will be performed in the RGB space.</p>',par:{RGBcolor:'desired RGB color when the transition is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['get_advertisedValue']={syn:'Returns the current value of the RGB led (no more than 6 characters).',lib:'YColorLed get_advertisedValue',pro:'YColorLed <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the RGB led (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB led (no more than 6 characters).',ext:''};
doc['ColorLed']['get_blinkSeqSignature']={syn:'Return the blinking sequence signature.',lib:'YColorLed get_blinkSeqSignature',pro:'YColorLed <span id=pn>target</span> get_blinkSeqSignature',cmt:'<p>Return the blinking sequence signature. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',ret:'an integer',ext:''};
doc['ColorLed']['get_hslColor']={syn:'Returns the current HSL color of the led.',lib:'YColorLed get_hslColor',pro:'YColorLed <span id=pn>target</span> get_hslColor',cmt:'<p>Returns the current HSL color of the led.</p>',ret:'an integer corresponding to the current HSL color of the led',ext:''};
doc['ColorLed']['get_logicalName']={syn:'Returns the logical name of the RGB led.',lib:'YColorLed get_logicalName',pro:'YColorLed <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the RGB led.</p>',ret:'a string corresponding to the logical name of the RGB led.',ext:''};
doc['ColorLed']['get_rgbColor']={syn:'Returns the current RGB color of the led.',lib:'YColorLed get_rgbColor',pro:'YColorLed <span id=pn>target</span> get_rgbColor',cmt:'<p>Returns the current RGB color of the led.</p>',ret:'an integer corresponding to the current RGB color of the led',ext:''};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Returns the configured color to be displayed when the module is turned on.',lib:'YColorLed get_rgbColorAtPowerOn',pro:'YColorLed <span id=pn>target</span> get_rgbColorAtPowerOn',cmt:'<p>Returns the configured color to be displayed when the module is turned on.</p>',ret:'an integer corresponding to the configured color to be displayed when the module is turned on',ext:''};
doc['ColorLed']['hslMove']={syn:'Performs a smooth transition in the HSL color space between the current color and a target color.',lib:'YColorLed hslMove',pro:'YColorLed <span id=pn>target</span> hslMove <span id=pn>hsl_target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth transition in the HSL color space between the current color and a target color.</p>',par:{hsl_target:'desired HSL color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['resetBlinkSeq']={syn:'Resets the preprogrammed blinking sequence.',lib:'YColorLed resetBlinkSeq',pro:'YColorLed <span id=pn>target</span> resetBlinkSeq',cmt:'<p>Resets the preprogrammed blinking sequence.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['rgbMove']={syn:'Performs a smooth transition in the RGB color space between the current color and a target color.',lib:'YColorLed rgbMove',pro:'YColorLed <span id=pn>target</span> rgbMove <span id=pn>rgb_target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth transition in the RGB color space between the current color and a target color.</p>',par:{rgb_target:'desired RGB color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['set_hslColor']={syn:'Changes the current color of the led, using a color HSL.',lib:'YColorLed set_hslColor',pro:'YColorLed <span id=pn>target</span> set_hslColor <span id=pn>newval</span>',cmt:'<p>Changes the current color of the led, using a color HSL. Encoding is done as follows: 0xHHSSLL.</p>',par:{newval:'an integer corresponding to the current color of the led, using a color HSL'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['set_logicalName']={syn:'Changes the logical name of the RGB led.',lib:'YColorLed set_logicalName',pro:'YColorLed <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the RGB led.</p>',par:{newval:'a string corresponding to the logical name of the RGB led.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['set_rgbColor']={syn:'Changes the current color of the led, using a RGB color.',lib:'YColorLed set_rgbColor',pro:'YColorLed <span id=pn>target</span> set_rgbColor <span id=pn>newval</span>',cmt:'<p>Changes the current color of the led, using a RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{newval:'an integer corresponding to the current color of the led, using a RGB color'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Changes the color that the led will display by default when the module is turned on.',lib:'YColorLed set_rgbColorAtPowerOn',pro:'YColorLed <span id=pn>target</span> set_rgbColorAtPowerOn <span id=pn>newval</span>',cmt:'<p>Changes the color that the led will display by default when the module is turned on.</p>',par:{newval:'an integer corresponding to the color that the led will display by default when the module is turned on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['ColorLed']['startBlinkSeq']={syn:'Starts the preprogrammed blinking sequence.',lib:'YColorLed startBlinkSeq',pro:'YColorLed <span id=pn>target</span> startBlinkSeq',cmt:'<p>Starts the preprogrammed blinking sequence. The sequence will run in loop until it is stopped by stopBlinkSeq or an explicit change.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['stopBlinkSeq']={syn:'Stops the preprogrammed blinking sequence.',lib:'YColorLed stopBlinkSeq',pro:'YColorLed <span id=pn>target</span> stopBlinkSeq',cmt:'<p>Stops the preprogrammed blinking sequence.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: ColorLed)
//--- (generated code: Current)
doc['Current']={'':{syn:'Current function interface',inc:'',cmt:'<p>The Yoctopuce class YCurrent allows you to read and configure Yoctopuce current sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Current']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YCurrent calibrateFromPoints',pro:'YCurrent <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['get_advertisedValue']={syn:'Returns the current value of the current sensor (no more than 6 characters).',lib:'YCurrent get_advertisedValue',pro:'YCurrent <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the current sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the current sensor (no more than 6 characters).',ext:''};
doc['Current']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.',lib:'YCurrent get_currentRawValue',pro:'YCurrent <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number',ext:''};
doc['Current']['get_currentValue']={syn:'Returns the current value of the current, in mA, as a floating point number.',lib:'YCurrent get_currentValue',pro:'YCurrent <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the current, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the current, in mA, as a floating point number',ext:''};
doc['Current']['get_highestValue']={syn:'Returns the maximal value observed for the current since the device was started.',lib:'YCurrent get_highestValue',pro:'YCurrent <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the current since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the current since the device was started',ext:''};
doc['Current']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YCurrent get_logFrequency',pro:'YCurrent <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Current']['get_logicalName']={syn:'Returns the logical name of the current sensor.',lib:'YCurrent get_logicalName',pro:'YCurrent <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the current sensor.</p>',ret:'a string corresponding to the logical name of the current sensor.',ext:''};
doc['Current']['get_lowestValue']={syn:'Returns the minimal value observed for the current since the device was started.',lib:'YCurrent get_lowestValue',pro:'YCurrent <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the current since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the current since the device was started',ext:''};
doc['Current']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YCurrent get_recordedData',pro:'YCurrent <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Current']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YCurrent get_reportFrequency',pro:'YCurrent <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Current']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YCurrent get_resolution',pro:'YCurrent <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Current']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YCurrent get_sensorState',pro:'YCurrent <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Current']['get_unit']={syn:'Returns the measuring unit for the current.',lib:'YCurrent get_unit',pro:'YCurrent <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the current.</p>',ret:'a string corresponding to the measuring unit for the current',ext:''};
doc['Current']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YCurrent isSensorReady',pro:'YCurrent <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Current']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YCurrent loadCalibrationPoints',pro:'YCurrent <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YCurrent set_highestValue',pro:'YCurrent <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YCurrent set_logFrequency',pro:'YCurrent <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_logicalName']={syn:'Changes the logical name of the current sensor.',lib:'YCurrent set_logicalName',pro:'YCurrent <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the current sensor.</p>',par:{newval:'a string corresponding to the logical name of the current sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YCurrent set_lowestValue',pro:'YCurrent <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YCurrent set_reportFrequency',pro:'YCurrent <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YCurrent set_resolution',pro:'YCurrent <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Current']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YCurrent startDataLogger',pro:'YCurrent <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Current']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YCurrent stopDataLogger',pro:'YCurrent <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Current)
//--- (generated code: DigitalIO)
doc['DigitalIO']={'':{syn:'Digital IO function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to switch the state of each bit of the I/O port. You can switch all bits at once, or one by one. The library can also automatically generate short pulses of a determined duration. Electrical behavior of each I/O can be modified (open drain and reverse polarity).</p>'}};
doc['DigitalIO']['delayedPulse']={syn:'Schedules a pulse on a single bit for a specified duration.',lib:'YDigitalIO delayedPulse',pro:'YDigitalIO <span id=pn>target</span> delayedPulse <span id=pn>bitno</span> <span id=pn>ms_delay</span> <span id=pn>ms_duration</span>',cmt:'<p>Schedules a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['get_advertisedValue']={syn:'Returns the current value of the digital IO port (no more than 6 characters).',lib:'YDigitalIO get_advertisedValue',pro:'YDigitalIO <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the digital IO port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the digital IO port (no more than 6 characters).',ext:''};
doc['DigitalIO']['get_bitDirection']={syn:'Returns the direction of a single bit from the I/O port (0 means the bit is an input, 1 an output).',lib:'YDigitalIO get_bitDirection',pro:'YDigitalIO <span id=pn>target</span> get_bitDirection <span id=pn>bitno</span>',cmt:'<p>Returns the direction of a single bit from the I/O port (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['get_bitOpenDrain']={syn:'Returns the type of electrical interface of a single bit from the I/O port.',lib:'YDigitalIO get_bitOpenDrain',pro:'YDigitalIO <span id=pn>target</span> get_bitOpenDrain <span id=pn>bitno</span>',cmt:'<p>Returns the type of electrical interface of a single bit from the I/O port. (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'0 means the a bit is a regular input/output, 1 means the bit is an open-drain (open-collector) input/output.',ext:''};
doc['DigitalIO']['get_bitPolarity']={syn:'Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).',lib:'YDigitalIO get_bitPolarity',pro:'YDigitalIO <span id=pn>target</span> get_bitPolarity <span id=pn>bitno</span>',cmt:'<p>Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['get_bitState']={syn:'Returns the state of a single bit of the I/O port.',lib:'YDigitalIO get_bitState',pro:'YDigitalIO <span id=pn>target</span> get_bitState <span id=pn>bitno</span>',cmt:'<p>Returns the state of a single bit of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'the bit state (0 or 1)',ext:''};
doc['DigitalIO']['get_logicalName']={syn:'Returns the logical name of the digital IO port.',lib:'YDigitalIO get_logicalName',pro:'YDigitalIO <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the digital IO port.</p>',ret:'a string corresponding to the logical name of the digital IO port.',ext:''};
doc['DigitalIO']['get_outputVoltage']={syn:'Returns the voltage source used to drive output bits.',lib:'YDigitalIO get_outputVoltage',pro:'YDigitalIO <span id=pn>target</span> get_outputVoltage',cmt:'<p>Returns the voltage source used to drive output bits.</p>',ret:'a value among <tt>USB_5V</tt>, <tt>USB_3V</tt> and <tt>EXT_V</tt> corresponding to the voltage source used to drive output bits',ext:''};
doc['DigitalIO']['get_portDirection']={syn:'Returns the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.',lib:'YDigitalIO get_portDirection',pro:'YDigitalIO <span id=pn>target</span> get_portDirection',cmt:'<p>Returns the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.</p>',ret:'an integer corresponding to the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output',ext:''};
doc['DigitalIO']['get_portOpenDrain']={syn:'Returns the electrical interface for each bit of the port.',lib:'YDigitalIO get_portOpenDrain',pro:'YDigitalIO <span id=pn>target</span> get_portOpenDrain',cmt:'<p>Returns the electrical interface for each bit of the port. For each bit set to 0 the matching I/O works in the regular, intuitive way, for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the electrical interface for each bit of the port',ext:''};
doc['DigitalIO']['get_portPolarity']={syn:'Returns the polarity of all the bits of the port.',lib:'YDigitalIO get_portPolarity',pro:'YDigitalIO <span id=pn>target</span> get_portPolarity',cmt:'<p>Returns the polarity of all the bits of the port. For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the polarity of all the bits of the port',ext:''};
doc['DigitalIO']['get_portSize']={syn:'Returns the number of bits implemented in the I/O port.',lib:'YDigitalIO get_portSize',pro:'YDigitalIO <span id=pn>target</span> get_portSize',cmt:'<p>Returns the number of bits implemented in the I/O port.</p>',ret:'an integer corresponding to the number of bits implemented in the I/O port',ext:''};
doc['DigitalIO']['get_portState']={syn:'Returns the digital IO port state: bit 0 represents input 0, and so on.',lib:'YDigitalIO get_portState',pro:'YDigitalIO <span id=pn>target</span> get_portState',cmt:'<p>Returns the digital IO port state: bit 0 represents input 0, and so on.</p>',ret:'an integer corresponding to the digital IO port state: bit 0 represents input 0, and so on',ext:''};
doc['DigitalIO']['pulse']={syn:'Triggers a pulse on a single bit for a specified duration.',lib:'YDigitalIO pulse',pro:'YDigitalIO <span id=pn>target</span> pulse <span id=pn>bitno</span> <span id=pn>ms_duration</span>',cmt:'<p>Triggers a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_bitDirection']={syn:'Changes the direction of a single bit from the I/O port.',lib:'YDigitalIO set_bitDirection',pro:'YDigitalIO <span id=pn>target</span> set_bitDirection <span id=pn>bitno</span> <span id=pn>bitdirection</span>',cmt:'<p>Changes the direction of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitdirection:'direction to set, 0 makes the bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_bitOpenDrain']={syn:'Changes the electrical interface of a single bit from the I/O port.',lib:'YDigitalIO set_bitOpenDrain',pro:'YDigitalIO <span id=pn>target</span> set_bitOpenDrain <span id=pn>bitno</span> <span id=pn>opendrain</span>',cmt:'<p>Changes the electrical interface of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',opendrain:'0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_bitPolarity']={syn:'Changes the polarity of a single bit from the I/O port.',lib:'YDigitalIO set_bitPolarity',pro:'YDigitalIO <span id=pn>target</span> set_bitPolarity <span id=pn>bitno</span> <span id=pn>bitpolarity</span>',cmt:'<p>Changes the polarity of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0.',bitpolarity:'polarity to set, 0 makes the I/O work in regular mode, 1 makes the I/O works in reverse mode. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_bitState']={syn:'Sets a single bit of the I/O port.',lib:'YDigitalIO set_bitState',pro:'YDigitalIO <span id=pn>target</span> set_bitState <span id=pn>bitno</span> <span id=pn>bitstate</span>',cmt:'<p>Sets a single bit of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitstate:'the state of the bit (1 or 0)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_logicalName']={syn:'Changes the logical name of the digital IO port.',lib:'YDigitalIO set_logicalName',pro:'YDigitalIO <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the digital IO port.</p>',par:{newval:'a string corresponding to the logical name of the digital IO port.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_outputVoltage']={syn:'Changes the voltage source used to drive output bits.',lib:'YDigitalIO set_outputVoltage',pro:'YDigitalIO <span id=pn>target</span> set_outputVoltage <span id=pn>newval</span>',cmt:'<p>Changes the voltage source used to drive output bits.</p>',par:{newval:'a value among <tt>USB_5V</tt>, <tt>USB_3V</tt> and <tt>EXT_V</tt> corresponding to the voltage source used to drive output bits'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_portDirection']={syn:'Changes the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.',lib:'YDigitalIO set_portDirection',pro:'YDigitalIO <span id=pn>target</span> set_portDirection <span id=pn>newval</span>',cmt:'<p>Changes the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.</p>',par:{newval:'an integer corresponding to the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_portOpenDrain']={syn:'Changes the electrical interface for each bit of the port.',lib:'YDigitalIO set_portOpenDrain',pro:'YDigitalIO <span id=pn>target</span> set_portOpenDrain <span id=pn>newval</span>',cmt:'<p>Changes the electrical interface for each bit of the port. 0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output.</p>',par:{newval:'an integer corresponding to the electrical interface for each bit of the port'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_portPolarity']={syn:'Changes the polarity of all the bits of the port: 0 makes a bit an input, 1 makes it an output.',lib:'YDigitalIO set_portPolarity',pro:'YDigitalIO <span id=pn>target</span> set_portPolarity <span id=pn>newval</span>',cmt:'<p>Changes the polarity of all the bits of the port: 0 makes a bit an input, 1 makes it an output.</p>',par:{newval:'an integer corresponding to the polarity of all the bits of the port: 0 makes a bit an input, 1 makes it an output'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['set_portState']={syn:'Changes the digital IO port state: bit 0 represents input 0, and so on.',lib:'YDigitalIO set_portState',pro:'YDigitalIO <span id=pn>target</span> set_portState <span id=pn>newval</span>',cmt:'<p>Changes the digital IO port state: bit 0 represents input 0, and so on. This function has no effect on bits configured as input in <tt>portDirection</tt>.</p>',par:{newval:'an integer corresponding to the digital IO port state: bit 0 represents input 0, and so on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DigitalIO']['toggle_bitState']={syn:'Reverts a single bit of the I/O port.',lib:'YDigitalIO toggle_bitState',pro:'YDigitalIO <span id=pn>target</span> toggle_bitState <span id=pn>bitno</span>',cmt:'<p>Reverts a single bit of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: DigitalIO)
//--- (generated code: Display)
doc['Display']={'':{syn:'Display function interface',inc:'',cmt:'<p>Yoctopuce display interface has been designed to easily show information and images. The device provides built-in multi-layer rendering. Layers can be drawn offline, individually, and freely moved on the display. It can also replay recorded sequences (animations).</p>'}};
doc['Display']['copyLayerContent']={syn:'Copies the whole content of a layer to another layer.',lib:'YDisplay copyLayerContent',pro:'YDisplay <span id=pn>target</span> copyLayerContent <span id=pn>srcLayerId</span> <span id=pn>dstLayerId</span>',cmt:'<p>Copies the whole content of a layer to another layer. The color and transparency of all the pixels from the destination layer are set to match the source pixels. This method only affects the displayed content, but does not change any property of the layer object. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{srcLayerId:'the identifier of the source layer (a number in range 0..layerCount-1)',dstLayerId:'the identifier of the destination layer (a number in range 0..layerCount-1)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['fade']={syn:'Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.',lib:'YDisplay fade',pro:'YDisplay <span id=pn>target</span> fade <span id=pn>brightness</span> <span id=pn>duration</span>',cmt:'<p>Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.</p>',par:{brightness:'the new screen brightness',duration:'duration of the brightness transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['get_advertisedValue']={syn:'Returns the current value of the display (no more than 6 characters).',lib:'YDisplay get_advertisedValue',pro:'YDisplay <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the display (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the display (no more than 6 characters).',ext:''};
doc['Display']['get_brightness']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'YDisplay get_brightness',pro:'YDisplay <span id=pn>target</span> get_brightness',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:''};
doc['Display']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'YDisplay get_displayHeight',pro:'YDisplay <span id=pn>target</span> get_displayHeight',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:''};
doc['Display']['get_displayType']={syn:'Returns the display type: monochrome, gray levels or full color.',lib:'YDisplay get_displayType',pro:'YDisplay <span id=pn>target</span> get_displayType',cmt:'<p>Returns the display type: monochrome, gray levels or full color.</p>',ret:'a value among <tt>MONO</tt>, <tt>GRAY</tt> and <tt>RGB</tt> corresponding to the display type: monochrome, gray levels or full color',ext:''};
doc['Display']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'YDisplay get_displayWidth',pro:'YDisplay <span id=pn>target</span> get_displayWidth',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:''};
doc['Display']['get_enabled']={syn:'Returns true if the screen is powered, false otherwise.',lib:'YDisplay get_enabled',pro:'YDisplay <span id=pn>target</span> get_enabled',cmt:'<p>Returns true if the screen is powered, false otherwise.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the screen is powered, false otherwise',ext:''};
doc['Display']['get_layerCount']={syn:'Returns the number of available layers to draw on.',lib:'YDisplay get_layerCount',pro:'YDisplay <span id=pn>target</span> get_layerCount',cmt:'<p>Returns the number of available layers to draw on.</p>',ret:'an integer corresponding to the number of available layers to draw on',ext:''};
doc['Display']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'YDisplay get_layerHeight',pro:'YDisplay <span id=pn>target</span> get_layerHeight',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:''};
doc['Display']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'YDisplay get_layerWidth',pro:'YDisplay <span id=pn>target</span> get_layerWidth',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:''};
doc['Display']['get_logicalName']={syn:'Returns the logical name of the display.',lib:'YDisplay get_logicalName',pro:'YDisplay <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the display.</p>',ret:'a string corresponding to the logical name of the display.',ext:''};
doc['Display']['get_orientation']={syn:'Returns the currently selected display orientation.',lib:'YDisplay get_orientation',pro:'YDisplay <span id=pn>target</span> get_orientation',cmt:'<p>Returns the currently selected display orientation.</p>',ret:'a value among <tt>LEFT</tt>, <tt>UP</tt>, <tt>RIGHT</tt> and <tt>DOWN</tt> corresponding to the currently selected display orientation',ext:''};
doc['Display']['get_startupSeq']={syn:'Returns the name of the sequence to play when the displayed is powered on.',lib:'YDisplay get_startupSeq',pro:'YDisplay <span id=pn>target</span> get_startupSeq',cmt:'<p>Returns the name of the sequence to play when the displayed is powered on.</p>',ret:'a string corresponding to the name of the sequence to play when the displayed is powered on',ext:''};
doc['Display']['newSequence']={syn:'Starts to record all display commands into a sequence, for later replay.',lib:'YDisplay newSequence',pro:'YDisplay <span id=pn>target</span> newSequence',cmt:'<p>Starts to record all display commands into a sequence, for later replay. The name used to store the sequence is specified when calling <tt>saveSequence()</tt>, once the recording is complete.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['pauseSequence']={syn:'Waits for a specified delay (in milliseconds) before playing next commands in current sequence.',lib:'YDisplay pauseSequence',pro:'YDisplay <span id=pn>target</span> pauseSequence <span id=pn>delay_ms</span>',cmt:'<p>Waits for a specified delay (in milliseconds) before playing next commands in current sequence. This method can be used while recording a display sequence, to insert a timed wait in the sequence (without any immediate effect). It can also be used dynamically while playing a pre-recorded sequence, to suspend or resume the execution of the sequence. To cancel a delay, call the same method with a zero delay.</p>',par:{delay_ms:'the duration to wait, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['playSequence']={syn:'Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.',lib:'YDisplay playSequence',pro:'YDisplay <span id=pn>target</span> playSequence <span id=pn>sequenceName</span>',cmt:'<p>Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['resetAll']={syn:'Clears the display screen and resets all display layers to their default state.',lib:'YDisplay resetAll',pro:'YDisplay <span id=pn>target</span> resetAll',cmt:'<p>Clears the display screen and resets all display layers to their default state. Using this function in a sequence will kill the sequence play-back. Don\x27t use that function to reset the display at sequence start-up.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['saveSequence']={syn:'Stops recording display commands and saves the sequence into the specified file on the display internal memory.',lib:'YDisplay saveSequence',pro:'YDisplay <span id=pn>target</span> saveSequence <span id=pn>sequenceName</span>',cmt:'<p>Stops recording display commands and saves the sequence into the specified file on the display internal memory. The sequence can be later replayed using <tt>playSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_brightness']={syn:'Changes the brightness of the display.',lib:'YDisplay set_brightness',pro:'YDisplay <span id=pn>target</span> set_brightness <span id=pn>newval</span>',cmt:'<p>Changes the brightness of the display. The parameter is a value between 0 and 100.</p>',par:{newval:'an integer corresponding to the brightness of the display'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_enabled']={syn:'Changes the power state of the display.',lib:'YDisplay set_enabled',pro:'YDisplay <span id=pn>target</span> set_enabled <span id=pn>newval</span>',cmt:'<p>Changes the power state of the display.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the power state of the display'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_logicalName']={syn:'Changes the logical name of the display.',lib:'YDisplay set_logicalName',pro:'YDisplay <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the display.</p>',par:{newval:'a string corresponding to the logical name of the display.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_orientation']={syn:'Changes the display orientation.',lib:'YDisplay set_orientation',pro:'YDisplay <span id=pn>target</span> set_orientation <span id=pn>newval</span>',cmt:'<p>Changes the display orientation.</p>',par:{newval:'a value among <tt>LEFT</tt>, <tt>UP</tt>, <tt>RIGHT</tt> and <tt>DOWN</tt> corresponding to the display orientation'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['set_startupSeq']={syn:'Changes the name of the sequence to play when the displayed is powered on.',lib:'YDisplay set_startupSeq',pro:'YDisplay <span id=pn>target</span> set_startupSeq <span id=pn>newval</span>',cmt:'<p>Changes the name of the sequence to play when the displayed is powered on.</p>',par:{newval:'a string corresponding to the name of the sequence to play when the displayed is powered on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['stopSequence']={syn:'Stops immediately any ongoing sequence replay.',lib:'YDisplay stopSequence',pro:'YDisplay <span id=pn>target</span> stopSequence',cmt:'<p>Stops immediately any ongoing sequence replay. The display is left as is.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['swapLayerContent']={syn:'Swaps the whole content of two layers.',lib:'YDisplay swapLayerContent',pro:'YDisplay <span id=pn>target</span> swapLayerContent <span id=pn>layerIdA</span> <span id=pn>layerIdB</span>',cmt:'<p>Swaps the whole content of two layers. The color and transparency of all the pixels from the two layers are swapped. This method only affects the displayed content, but does not change any property of the layer objects. In particular, the visibility of each layer stays unchanged. When used between onae hidden layer and a visible layer, this method makes it possible to easily implement double-buffering. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{layerIdA:'the first layer (a number in range 0..layerCount-1)',layerIdB:'the second layer (a number in range 0..layerCount-1)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Display']['upload']={syn:'Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name.',lib:'YDisplay upload',pro:'YDisplay <span id=pn>target</span> upload <span id=pn>pathname</span> <span id=pn>content</span>',cmt:'<p>Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Display)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'External power supply control interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to control the power source to use for module functions that require high current. The module can also automatically disconnect the external power when a voltage drop is observed on the external power source (external battery running out of power).</p>'}};
doc['DualPower']['get_advertisedValue']={syn:'Returns the current value of the power control (no more than 6 characters).',lib:'YDualPower get_advertisedValue',pro:'YDualPower <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the power control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power control (no more than 6 characters).',ext:''};
doc['DualPower']['get_extVoltage']={syn:'Returns the measured voltage on the external power source, in millivolts.',lib:'YDualPower get_extVoltage',pro:'YDualPower <span id=pn>target</span> get_extVoltage',cmt:'<p>Returns the measured voltage on the external power source, in millivolts.</p>',ret:'an integer corresponding to the measured voltage on the external power source, in millivolts',ext:''};
doc['DualPower']['get_logicalName']={syn:'Returns the logical name of the power control.',lib:'YDualPower get_logicalName',pro:'YDualPower <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the power control.</p>',ret:'a string corresponding to the logical name of the power control.',ext:''};
doc['DualPower']['get_powerControl']={syn:'Returns the selected power source for module functions that require lots of current.',lib:'YDualPower get_powerControl',pro:'YDualPower <span id=pn>target</span> get_powerControl',cmt:'<p>Returns the selected power source for module functions that require lots of current.</p>',ret:'a value among <tt>AUTO</tt>, <tt>FROM_USB</tt>, <tt>FROM_EXT</tt> and <tt>OFF</tt> corresponding to the selected power source for module functions that require lots of current',ext:''};
doc['DualPower']['get_powerState']={syn:'Returns the current power source for module functions that require lots of current.',lib:'YDualPower get_powerState',pro:'YDualPower <span id=pn>target</span> get_powerState',cmt:'<p>Returns the current power source for module functions that require lots of current.</p>',ret:'a value among <tt>OFF</tt>, <tt>FROM_USB</tt> and <tt>FROM_EXT</tt> corresponding to the current power source for module functions that require lots of current',ext:''};
doc['DualPower']['set_logicalName']={syn:'Changes the logical name of the power control.',lib:'YDualPower set_logicalName',pro:'YDualPower <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the power control.</p>',par:{newval:'a string corresponding to the logical name of the power control.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['DualPower']['set_powerControl']={syn:'Changes the selected power source for module functions that require lots of current.',lib:'YDualPower set_powerControl',pro:'YDualPower <span id=pn>target</span> set_powerControl <span id=pn>newval</span>',cmt:'<p>Changes the selected power source for module functions that require lots of current.</p>',par:{newval:'a value among <tt>AUTO</tt>, <tt>FROM_USB</tt>, <tt>FROM_EXT</tt> and <tt>OFF</tt> corresponding to the selected power source for module functions that require lots of current'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: DualPower)
//--- (generated code: Files)
doc['Files']={'':{syn:'Files function interface',inc:'',cmt:'<p>The filesystem interface makes it possible to store files on some devices, for instance to design a custom web UI (for networked devices) or to add fonts (on display devices).</p>'}};
doc['Files']['download']={syn:'Downloads the requested file and returns a binary buffer with its content.',lib:'YFiles download',pro:'YFiles <span id=pn>target</span> download <span id=pn>pathname</span>',cmt:'<p>Downloads the requested file and returns a binary buffer with its content.</p>',par:{pathname:'path and name of the file to download'},ret:'a binary buffer with the file content',ext:''};
doc['Files']['format_fs']={syn:'Reinitialize the filesystem to its clean, unfragmented, empty state.',lib:'YFiles format_fs',pro:'YFiles <span id=pn>target</span> format_fs',cmt:'<p>Reinitialize the filesystem to its clean, unfragmented, empty state. All files previously uploaded are permanently lost.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Files']['get_advertisedValue']={syn:'Returns the current value of the filesystem (no more than 6 characters).',lib:'YFiles get_advertisedValue',pro:'YFiles <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the filesystem (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the filesystem (no more than 6 characters).',ext:''};
doc['Files']['get_filesCount']={syn:'Returns the number of files currently loaded in the filesystem.',lib:'YFiles get_filesCount',pro:'YFiles <span id=pn>target</span> get_filesCount',cmt:'<p>Returns the number of files currently loaded in the filesystem.</p>',ret:'an integer corresponding to the number of files currently loaded in the filesystem',ext:''};
doc['Files']['get_freeSpace']={syn:'Returns the free space for uploading new files to the filesystem, in bytes.',lib:'YFiles get_freeSpace',pro:'YFiles <span id=pn>target</span> get_freeSpace',cmt:'<p>Returns the free space for uploading new files to the filesystem, in bytes.</p>',ret:'an integer corresponding to the free space for uploading new files to the filesystem, in bytes',ext:''};
doc['Files']['get_list']={syn:'Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.',lib:'YFiles get_list',pro:'YFiles <span id=pn>target</span> get_list <span id=pn>pattern</span>',cmt:'<p>Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.</p>',par:{pattern:'an optional filter pattern, using star and question marks as wildcards. When an empty pattern is provided, all file records are returned.'},ret:'a list of <tt>YFileRecord</tt> objects, containing the file path and name, byte size and 32-bit CRC of the file content.',ext:''};
doc['Files']['get_logicalName']={syn:'Returns the logical name of the filesystem.',lib:'YFiles get_logicalName',pro:'YFiles <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the filesystem.</p>',ret:'a string corresponding to the logical name of the filesystem.',ext:''};
doc['Files']['remove']={syn:'Deletes a file, given by its full path name, from the filesystem.',lib:'YFiles remove',pro:'YFiles <span id=pn>target</span> remove <span id=pn>pathname</span>',cmt:'<p>Deletes a file, given by its full path name, from the filesystem. Because of filesystem fragmentation, deleting a file may not always free up the whole space used by the file. However, rewriting a file with the same path name will always reuse any space not freed previously. If you need to ensure that no space is taken by previously deleted files, you can use <tt>format_fs</tt> to fully reinitialize the filesystem.</p>',par:{pathname:'path and name of the file to remove.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Files']['set_logicalName']={syn:'Changes the logical name of the filesystem.',lib:'YFiles set_logicalName',pro:'YFiles <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the filesystem.</p>',par:{newval:'a string corresponding to the logical name of the filesystem.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Files']['upload']={syn:'Uploads a file to the filesystem, to the specified full path name.',lib:'YFiles upload',pro:'YFiles <span id=pn>target</span> upload <span id=pn>pathname</span> <span id=pn>content</span>',cmt:'<p>Uploads a file to the filesystem, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Files)
//--- (generated code: GenericSensor)
doc['GenericSensor']={'':{syn:'GenericSensor function interface',inc:'',cmt:'<p>The YGenericSensor class allows you to read and configure Yoctopuce signal transducers. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to configure the automatic conversion between the measured signal and the corresponding engineering unit.</p>'}};
doc['GenericSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YGenericSensor calibrateFromPoints',pro:'YGenericSensor <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['get_advertisedValue']={syn:'Returns the current value of the generic sensor (no more than 6 characters).',lib:'YGenericSensor get_advertisedValue',pro:'YGenericSensor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the generic sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the generic sensor (no more than 6 characters).',ext:''};
doc['GenericSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'YGenericSensor get_currentRawValue',pro:'YGenericSensor <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:''};
doc['GenericSensor']['get_currentValue']={syn:'Returns the current measured value.',lib:'YGenericSensor get_currentValue',pro:'YGenericSensor <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:''};
doc['GenericSensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'YGenericSensor get_highestValue',pro:'YGenericSensor <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the measure since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:''};
doc['GenericSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YGenericSensor get_logFrequency',pro:'YGenericSensor <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['GenericSensor']['get_logicalName']={syn:'Returns the logical name of the generic sensor.',lib:'YGenericSensor get_logicalName',pro:'YGenericSensor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the generic sensor.</p>',ret:'a string corresponding to the logical name of the generic sensor.',ext:''};
doc['GenericSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'YGenericSensor get_lowestValue',pro:'YGenericSensor <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the measure since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:''};
doc['GenericSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YGenericSensor get_recordedData',pro:'YGenericSensor <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GenericSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YGenericSensor get_reportFrequency',pro:'YGenericSensor <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['GenericSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YGenericSensor get_resolution',pro:'YGenericSensor <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['GenericSensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YGenericSensor get_sensorState',pro:'YGenericSensor <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['GenericSensor']['get_signalBias']={syn:'Returns the electric signal bias for zero shift adjustment.',lib:'YGenericSensor get_signalBias',pro:'YGenericSensor <span id=pn>target</span> get_signalBias',cmt:'<p>Returns the electric signal bias for zero shift adjustment. A positive bias means that the signal is over-reporting the measure, while a negative bias means that the signal is underreporting the measure.</p>',ret:'a floating point number corresponding to the electric signal bias for zero shift adjustment',ext:''};
doc['GenericSensor']['get_signalRange']={syn:'Returns the electric signal range used by the sensor.',lib:'YGenericSensor get_signalRange',pro:'YGenericSensor <span id=pn>target</span> get_signalRange',cmt:'<p>Returns the electric signal range used by the sensor.</p>',ret:'a string corresponding to the electric signal range used by the sensor',ext:''};
doc['GenericSensor']['get_signalSampling']={syn:'Returns the electric signal sampling method to use.',lib:'YGenericSensor get_signalSampling',pro:'YGenericSensor <span id=pn>target</span> get_signalSampling',cmt:'<p>Returns the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',ret:'a value among <tt>HIGH_RATE</tt>, <tt>HIGH_RATE_FILTERED</tt>, <tt>LOW_NOISE</tt> and <tt>LOW_NOISE_FILTERED</tt> corresponding to the electric signal sampling method to use',ext:''};
doc['GenericSensor']['get_signalUnit']={syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'YGenericSensor get_signalUnit',pro:'YGenericSensor <span id=pn>target</span> get_signalUnit',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:''};
doc['GenericSensor']['get_signalValue']={syn:'Returns the measured value of the electrical signal used by the sensor.',lib:'YGenericSensor get_signalValue',pro:'YGenericSensor <span id=pn>target</span> get_signalValue',cmt:'<p>Returns the measured value of the electrical signal used by the sensor.</p>',ret:'a floating point number corresponding to the measured value of the electrical signal used by the sensor',ext:''};
doc['GenericSensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'YGenericSensor get_unit',pro:'YGenericSensor <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:''};
doc['GenericSensor']['get_valueRange']={syn:'Returns the physical value range measured by the sensor.',lib:'YGenericSensor get_valueRange',pro:'YGenericSensor <span id=pn>target</span> get_valueRange',cmt:'<p>Returns the physical value range measured by the sensor.</p>',ret:'a string corresponding to the physical value range measured by the sensor',ext:''};
doc['GenericSensor']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YGenericSensor isSensorReady',pro:'YGenericSensor <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['GenericSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YGenericSensor loadCalibrationPoints',pro:'YGenericSensor <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YGenericSensor set_highestValue',pro:'YGenericSensor <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YGenericSensor set_logFrequency',pro:'YGenericSensor <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_logicalName']={syn:'Changes the logical name of the generic sensor.',lib:'YGenericSensor set_logicalName',pro:'YGenericSensor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the generic sensor.</p>',par:{newval:'a string corresponding to the logical name of the generic sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YGenericSensor set_lowestValue',pro:'YGenericSensor <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YGenericSensor set_reportFrequency',pro:'YGenericSensor <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YGenericSensor set_resolution',pro:'YGenericSensor <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_signalBias']={syn:'Changes the electric signal bias for zero shift adjustment.',lib:'YGenericSensor set_signalBias',pro:'YGenericSensor <span id=pn>target</span> set_signalBias <span id=pn>newval</span>',cmt:'<p>Changes the electric signal bias for zero shift adjustment. If your electric signal reads positif when it should be zero, setup a positive signalBias of the same value to fix the zero shift.</p>',par:{newval:'a floating point number corresponding to the electric signal bias for zero shift adjustment'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_signalRange']={syn:'Changes the electric signal range used by the sensor.',lib:'YGenericSensor set_signalRange',pro:'YGenericSensor <span id=pn>target</span> set_signalRange <span id=pn>newval</span>',cmt:'<p>Changes the electric signal range used by the sensor.</p>',par:{newval:'a string corresponding to the electric signal range used by the sensor'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_signalSampling']={syn:'Changes the electric signal sampling method to use.',lib:'YGenericSensor set_signalSampling',pro:'YGenericSensor <span id=pn>target</span> set_signalSampling <span id=pn>newval</span>',cmt:'<p>Changes the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',par:{newval:'a value among <tt>HIGH_RATE</tt>, <tt>HIGH_RATE_FILTERED</tt>, <tt>LOW_NOISE</tt> and <tt>LOW_NOISE_FILTERED</tt> corresponding to the electric signal sampling method to use'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_unit']={syn:'Changes the measuring unit for the measured value.',lib:'YGenericSensor set_unit',pro:'YGenericSensor <span id=pn>target</span> set_unit <span id=pn>newval</span>',cmt:'<p>Changes the measuring unit for the measured value.</p>',par:{newval:'a string corresponding to the measuring unit for the measured value'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['set_valueRange']={syn:'Changes the physical value range measured by the sensor.',lib:'YGenericSensor set_valueRange',pro:'YGenericSensor <span id=pn>target</span> set_valueRange <span id=pn>newval</span>',cmt:'<p>Changes the physical value range measured by the sensor. As a side effect, the range modification may automatically modify the display resolution.</p>',par:{newval:'a string corresponding to the physical value range measured by the sensor'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GenericSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YGenericSensor startDataLogger',pro:'YGenericSensor <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['GenericSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YGenericSensor stopDataLogger',pro:'YGenericSensor <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['GenericSensor']['zeroAdjust']={syn:'Adjusts the signal bias so that the current signal value is need precisely as zero.',lib:'YGenericSensor zeroAdjust',pro:'YGenericSensor <span id=pn>target</span> zeroAdjust',cmt:'<p>Adjusts the signal bias so that the current signal value is need precisely as zero.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: GenericSensor)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Yocto-hub port interface',inc:'',cmt:'<p>YHubPort objects provide control over the power supply for every YoctoHub port and provide information about the device connected to it. The logical name of a YHubPort is always automatically set to the unique serial number of the Yoctopuce device connected to it.</p>'}};
doc['HubPort']['get_advertisedValue']={syn:'Returns the current value of the Yocto-hub port (no more than 6 characters).',lib:'YHubPort get_advertisedValue',pro:'YHubPort <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the Yocto-hub port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Yocto-hub port (no more than 6 characters).',ext:''};
doc['HubPort']['get_baudRate']={syn:'Returns the current baud rate used by this Yocto-hub port, in kbps.',lib:'YHubPort get_baudRate',pro:'YHubPort <span id=pn>target</span> get_baudRate',cmt:'<p>Returns the current baud rate used by this Yocto-hub port, in kbps. The default value is 1000 kbps, but a slower rate may be used if communication problems are encountered.</p>',ret:'an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps',ext:''};
doc['HubPort']['get_enabled']={syn:'Returns true if the Yocto-hub port is powered, false otherwise.',lib:'YHubPort get_enabled',pro:'YHubPort <span id=pn>target</span> get_enabled',cmt:'<p>Returns true if the Yocto-hub port is powered, false otherwise.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the Yocto-hub port is powered, false otherwise',ext:''};
doc['HubPort']['get_logicalName']={syn:'Returns the logical name of the Yocto-hub port.',lib:'YHubPort get_logicalName',pro:'YHubPort <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the Yocto-hub port.</p>',ret:'a string corresponding to the logical name of the Yocto-hub port.',ext:''};
doc['HubPort']['get_portState']={syn:'Returns the current state of the Yocto-hub port.',lib:'YHubPort get_portState',pro:'YHubPort <span id=pn>target</span> get_portState',cmt:'<p>Returns the current state of the Yocto-hub port.</p>',ret:'a value among <tt>OFF</tt>, <tt>OVRLD</tt>, <tt>ON</tt>, <tt>RUN</tt> and <tt>PROG</tt> corresponding to the current state of the Yocto-hub port',ext:''};
doc['HubPort']['set_enabled']={syn:'Changes the activation of the Yocto-hub port.',lib:'YHubPort set_enabled',pro:'YHubPort <span id=pn>target</span> set_enabled <span id=pn>newval</span>',cmt:'<p>Changes the activation of the Yocto-hub port. If the port is enabled, the connected module is powered. Otherwise, port power is shut down.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the activation of the Yocto-hub port'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['HubPort']['set_logicalName']={syn:'Changes the logical name of the Yocto-hub port.',lib:'YHubPort set_logicalName',pro:'YHubPort <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the Yocto-hub port.</p>',par:{newval:'a string corresponding to the logical name of the Yocto-hub port.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: HubPort)
//--- (generated code: Led)
doc['Led']={'':{syn:'Led function interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you not only to drive the intensity of the led, but also to have it blink at various preset frequencies.</p>'}};
doc['Led']['get_advertisedValue']={syn:'Returns the current value of the led (no more than 6 characters).',lib:'YLed get_advertisedValue',pro:'YLed <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the led (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the led (no more than 6 characters).',ext:''};
doc['Led']['get_blinking']={syn:'Returns the current led signaling mode.',lib:'YLed get_blinking',pro:'YLed <span id=pn>target</span> get_blinking',cmt:'<p>Returns the current led signaling mode.</p>',ret:'a value among <tt>STILL</tt>, <tt>RELAX</tt>, <tt>AWARE</tt>, <tt>RUN</tt>, <tt>CALL</tt> and <tt>PANIC</tt> corresponding to the current led signaling mode',ext:''};
doc['Led']['get_logicalName']={syn:'Returns the logical name of the led.',lib:'YLed get_logicalName',pro:'YLed <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the led.</p>',ret:'a string corresponding to the logical name of the led.',ext:''};
doc['Led']['get_luminosity']={syn:'Returns the current led intensity (in per cent).',lib:'YLed get_luminosity',pro:'YLed <span id=pn>target</span> get_luminosity',cmt:'<p>Returns the current led intensity (in per cent).</p>',ret:'an integer corresponding to the current led intensity (in per cent)',ext:''};
doc['Led']['get_power']={syn:'Returns the current led state.',lib:'YLed get_power',pro:'YLed <span id=pn>target</span> get_power',cmt:'<p>Returns the current led state.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the current led state',ext:''};
doc['Led']['set_blinking']={syn:'Changes the current led signaling mode.',lib:'YLed set_blinking',pro:'YLed <span id=pn>target</span> set_blinking <span id=pn>newval</span>',cmt:'<p>Changes the current led signaling mode.</p>',par:{newval:'a value among <tt>STILL</tt>, <tt>RELAX</tt>, <tt>AWARE</tt>, <tt>RUN</tt>, <tt>CALL</tt> and <tt>PANIC</tt> corresponding to the current led signaling mode'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Led']['set_logicalName']={syn:'Changes the logical name of the led.',lib:'YLed set_logicalName',pro:'YLed <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the led.</p>',par:{newval:'a string corresponding to the logical name of the led.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Led']['set_luminosity']={syn:'Changes the current led intensity (in per cent).',lib:'YLed set_luminosity',pro:'YLed <span id=pn>target</span> set_luminosity <span id=pn>newval</span>',cmt:'<p>Changes the current led intensity (in per cent).</p>',par:{newval:'an integer corresponding to the current led intensity (in per cent)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Led']['set_power']={syn:'Changes the state of the led.',lib:'YLed set_power',pro:'YLed <span id=pn>target</span> set_power <span id=pn>newval</span>',cmt:'<p>Changes the state of the led.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the state of the led'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Led)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'LightSensor function interface',inc:'',cmt:'<p>The Yoctopuce class YLightSensor allows you to read and configure Yoctopuce light sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor. For some light sensors with several working modes, this class can select the desired working mode.</p>'}};
doc['LightSensor']['calibrate']={syn:'Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).',lib:'YLightSensor calibrate',pro:'YLightSensor <span id=pn>target</span> calibrate <span id=pn>calibratedVal</span>',cmt:'<p>Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).</p>',par:{calibratedVal:'the desired target value.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YLightSensor calibrateFromPoints',pro:'YLightSensor <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['get_advertisedValue']={syn:'Returns the current value of the light sensor (no more than 6 characters).',lib:'YLightSensor get_advertisedValue',pro:'YLightSensor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the light sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the light sensor (no more than 6 characters).',ext:''};
doc['LightSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in lux, as a floating point number.',lib:'YLightSensor get_currentRawValue',pro:'YLightSensor <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in lux, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in lux, as a floating point number',ext:''};
doc['LightSensor']['get_currentValue']={syn:'Returns the current value of the ambient light, in lux, as a floating point number.',lib:'YLightSensor get_currentValue',pro:'YLightSensor <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the ambient light, in lux, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ambient light, in lux, as a floating point number',ext:''};
doc['LightSensor']['get_highestValue']={syn:'Returns the maximal value observed for the ambient light since the device was started.',lib:'YLightSensor get_highestValue',pro:'YLightSensor <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the ambient light since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the ambient light since the device was started',ext:''};
doc['LightSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YLightSensor get_logFrequency',pro:'YLightSensor <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['LightSensor']['get_logicalName']={syn:'Returns the logical name of the light sensor.',lib:'YLightSensor get_logicalName',pro:'YLightSensor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the light sensor.</p>',ret:'a string corresponding to the logical name of the light sensor.',ext:''};
doc['LightSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the ambient light since the device was started.',lib:'YLightSensor get_lowestValue',pro:'YLightSensor <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the ambient light since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the ambient light since the device was started',ext:''};
doc['LightSensor']['get_measureType']={syn:'Returns the type of light measure.',lib:'YLightSensor get_measureType',pro:'YLightSensor <span id=pn>target</span> get_measureType',cmt:'<p>Returns the type of light measure.</p>',ret:'a value among <tt>HUMAN_EYE</tt>, <tt>WIDE_SPECTRUM</tt>, <tt>INFRARED</tt>, <tt>HIGH_RATE</tt> and <tt>HIGH_ENERGY</tt> corresponding to the type of light measure',ext:''};
doc['LightSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YLightSensor get_recordedData',pro:'YLightSensor <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['LightSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YLightSensor get_reportFrequency',pro:'YLightSensor <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['LightSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YLightSensor get_resolution',pro:'YLightSensor <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['LightSensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YLightSensor get_sensorState',pro:'YLightSensor <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['LightSensor']['get_unit']={syn:'Returns the measuring unit for the ambient light.',lib:'YLightSensor get_unit',pro:'YLightSensor <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the ambient light.</p>',ret:'a string corresponding to the measuring unit for the ambient light',ext:''};
doc['LightSensor']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YLightSensor isSensorReady',pro:'YLightSensor <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['LightSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YLightSensor loadCalibrationPoints',pro:'YLightSensor <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YLightSensor set_highestValue',pro:'YLightSensor <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YLightSensor set_logFrequency',pro:'YLightSensor <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_logicalName']={syn:'Changes the logical name of the light sensor.',lib:'YLightSensor set_logicalName',pro:'YLightSensor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the light sensor.</p>',par:{newval:'a string corresponding to the logical name of the light sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YLightSensor set_lowestValue',pro:'YLightSensor <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_measureType']={syn:'Modify the light sensor type used in the device.',lib:'YLightSensor set_measureType',pro:'YLightSensor <span id=pn>target</span> set_measureType <span id=pn>newval</span>',cmt:'<p>Modify the light sensor type used in the device. The measure can either approximate the response of the human eye, focus on a specific light spectrum, depending on the capabilities of the light-sensitive cell.</p>',par:{newval:'a value among <tt>HUMAN_EYE</tt>, <tt>WIDE_SPECTRUM</tt>, <tt>INFRARED</tt>, <tt>HIGH_RATE</tt> and <tt>HIGH_ENERGY</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YLightSensor set_reportFrequency',pro:'YLightSensor <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YLightSensor set_resolution',pro:'YLightSensor <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['LightSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YLightSensor startDataLogger',pro:'YLightSensor <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['LightSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YLightSensor stopDataLogger',pro:'YLightSensor <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: LightSensor)
//--- (generated code: Network)
doc['Network']={'':{syn:'Network function interface',inc:'',cmt:'<p>YNetwork objects provide access to TCP/IP parameters of Yoctopuce modules that include a built-in network interface.</p>'}};
doc['Network']['callbackLogin']={syn:'Connects to the notification callback and saves the credentials required to log into it.',lib:'YNetwork callbackLogin',pro:'YNetwork <span id=pn>target</span> callbackLogin <span id=pn>username</span> <span id=pn>password</span>',cmt:'<p>Connects to the notification callback and saves the credentials required to log into it. The password is not stored into the module, only a hashed copy of the credentials are saved.</p>',par:{username:'username required to log to the callback',password:'password required to log to the callback'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['get_adminPassword']={syn:'Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.',lib:'YNetwork get_adminPassword',pro:'YNetwork <span id=pn>target</span> get_adminPassword',cmt:'<p>Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise',ext:''};
doc['Network']['get_advertisedValue']={syn:'Returns the current value of the network interface (no more than 6 characters).',lib:'YNetwork get_advertisedValue',pro:'YNetwork <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the network interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the network interface (no more than 6 characters).',ext:''};
doc['Network']['get_callbackCredentials']={syn:'Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.',lib:'YNetwork get_callbackCredentials',pro:'YNetwork <span id=pn>target</span> get_callbackCredentials',cmt:'<p>Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.</p>',ret:'a string corresponding to a hashed version of the notification callback credentials if set, or an empty string otherwise',ext:''};
doc['Network']['get_callbackEncoding']={syn:'Returns the encoding standard to use for representing notification values.',lib:'YNetwork get_callbackEncoding',pro:'YNetwork <span id=pn>target</span> get_callbackEncoding',cmt:'<p>Returns the encoding standard to use for representing notification values.</p>',ret:'a value among <tt>FORM</tt>, <tt>JSON</tt>, <tt>JSON_ARRAY</tt>, <tt>CSV</tt>, <tt>YOCTO_API</tt>, <tt>JSON_NUM</tt>, <tt>EMONCMS</tt> and <tt>AZURE</tt> corresponding to the encoding standard to use for representing notification values',ext:''};
doc['Network']['get_callbackMaxDelay']={syn:'Returns the maximum waiting time between two callback notifications, in seconds.',lib:'YNetwork get_callbackMaxDelay',pro:'YNetwork <span id=pn>target</span> get_callbackMaxDelay',cmt:'<p>Returns the maximum waiting time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the maximum waiting time between two callback notifications, in seconds',ext:''};
doc['Network']['get_callbackMethod']={syn:'Returns the HTTP method used to notify callbacks for significant state changes.',lib:'YNetwork get_callbackMethod',pro:'YNetwork <span id=pn>target</span> get_callbackMethod',cmt:'<p>Returns the HTTP method used to notify callbacks for significant state changes.</p>',ret:'a value among <tt>POST</tt>, <tt>GET</tt> and <tt>PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes',ext:''};
doc['Network']['get_callbackMinDelay']={syn:'Returns the minimum waiting time between two callback notifications, in seconds.',lib:'YNetwork get_callbackMinDelay',pro:'YNetwork <span id=pn>target</span> get_callbackMinDelay',cmt:'<p>Returns the minimum waiting time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the minimum waiting time between two callback notifications, in seconds',ext:''};
doc['Network']['get_callbackUrl']={syn:'Returns the callback URL to notify of significant state changes.',lib:'YNetwork get_callbackUrl',pro:'YNetwork <span id=pn>target</span> get_callbackUrl',cmt:'<p>Returns the callback URL to notify of significant state changes.</p>',ret:'a string corresponding to the callback URL to notify of significant state changes',ext:''};
doc['Network']['get_defaultPage']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'YNetwork get_defaultPage',pro:'YNetwork <span id=pn>target</span> get_defaultPage',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'a string corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:''};
doc['Network']['get_discoverable']={syn:'Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'YNetwork get_discoverable',pro:'YNetwork <span id=pn>target</span> get_discoverable',cmt:'<p>Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)',ext:''};
doc['Network']['get_httpPort']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'YNetwork get_httpPort',pro:'YNetwork <span id=pn>target</span> get_httpPort',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'an integer corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:''};
doc['Network']['get_ipAddress']={syn:'Returns the IP address currently in use by the device.',lib:'YNetwork get_ipAddress',pro:'YNetwork <span id=pn>target</span> get_ipAddress',cmt:'<p>Returns the IP address currently in use by the device. The address may have been configured statically, or provided by a DHCP server.</p>',ret:'a string corresponding to the IP address currently in use by the device',ext:''};
doc['Network']['get_logicalName']={syn:'Returns the logical name of the network interface.',lib:'YNetwork get_logicalName',pro:'YNetwork <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the network interface.</p>',ret:'a string corresponding to the logical name of the network interface.',ext:''};
doc['Network']['get_macAddress']={syn:'Returns the MAC address of the network interface.',lib:'YNetwork get_macAddress',pro:'YNetwork <span id=pn>target</span> get_macAddress',cmt:'<p>Returns the MAC address of the network interface. The MAC address is also available on a sticker on the module, in both numeric and barcode forms.</p>',ret:'a string corresponding to the MAC address of the network interface',ext:''};
doc['Network']['get_ntpServer']={syn:'Returns the IP address of the NTP server to be used by the device.',lib:'YNetwork get_ntpServer',pro:'YNetwork <span id=pn>target</span> get_ntpServer',cmt:'<p>Returns the IP address of the NTP server to be used by the device.</p>',ret:'a string corresponding to the IP address of the NTP server to be used by the device',ext:''};
doc['Network']['get_poeCurrent']={syn:'Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps.',lib:'YNetwork get_poeCurrent',pro:'YNetwork <span id=pn>target</span> get_poeCurrent',cmt:'<p>Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps. The current consumption is measured after converting PoE source to 5 Volt, and should never exceed 1800 mA.</p>',ret:'an integer corresponding to the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps',ext:''};
doc['Network']['get_primaryDNS']={syn:'Returns the IP address of the primary name server to be used by the module.',lib:'YNetwork get_primaryDNS',pro:'YNetwork <span id=pn>target</span> get_primaryDNS',cmt:'<p>Returns the IP address of the primary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the primary name server to be used by the module',ext:''};
doc['Network']['get_readiness']={syn:'Returns the current established working mode of the network interface.',lib:'YNetwork get_readiness',pro:'YNetwork <span id=pn>target</span> get_readiness',cmt:'<p>Returns the current established working mode of the network interface. Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal on the network cable, or the selected wireless access point cannot be detected. Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected. For a wireless network, this shows that the requested SSID is present. Level 2 (LINK_2) is reached when the hardware connection is established. For a wired network connection, level 2 means that the cable is attached at both ends. For a connection to a wireless access point, it shows that the security parameters are properly configured. For an ad-hoc wireless connection, it means that there is at least one other device connected on the ad-hoc network. Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP. Level 4 (DNS_4) is reached when the DNS server is reachable on the network. Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the current time from an NTP server.</p>',ret:'a value among <tt>DOWN</tt>, <tt>EXISTS</tt>, <tt>LINKED</tt>, <tt>LAN_OK</tt> and <tt>WWW_OK</tt> corresponding to the current established working mode of the network interface',ext:''};
doc['Network']['get_router']={syn:'Returns the IP address of the router on the device subnet (default gateway).',lib:'YNetwork get_router',pro:'YNetwork <span id=pn>target</span> get_router',cmt:'<p>Returns the IP address of the router on the device subnet (default gateway).</p>',ret:'a string corresponding to the IP address of the router on the device subnet (default gateway)',ext:''};
doc['Network']['get_secondaryDNS']={syn:'Returns the IP address of the secondary name server to be used by the module.',lib:'YNetwork get_secondaryDNS',pro:'YNetwork <span id=pn>target</span> get_secondaryDNS',cmt:'<p>Returns the IP address of the secondary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the secondary name server to be used by the module',ext:''};
doc['Network']['get_subnetMask']={syn:'Returns the subnet mask currently used by the device.',lib:'YNetwork get_subnetMask',pro:'YNetwork <span id=pn>target</span> get_subnetMask',cmt:'<p>Returns the subnet mask currently used by the device.</p>',ret:'a string corresponding to the subnet mask currently used by the device',ext:''};
doc['Network']['get_userPassword']={syn:'Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.',lib:'YNetwork get_userPassword',pro:'YNetwork <span id=pn>target</span> get_userPassword',cmt:'<p>Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise',ext:''};
doc['Network']['get_wwwWatchdogDelay']={syn:'Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'YNetwork get_wwwWatchdogDelay',pro:'YNetwork <span id=pn>target</span> get_wwwWatchdogDelay',cmt:'<p>Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss.</p>',ret:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity',ext:''};
doc['Network']['ping']={syn:'Pings str_host to test the network connectivity.',lib:'YNetwork ping',pro:'YNetwork <span id=pn>target</span> ping <span id=pn>host</span>',cmt:'<p>Pings str_host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the module to the target str_host. This method returns a string with the result of the 4 ICMP ECHO_REQUEST requests.</p>',par:{host:'the hostname or the IP address of the target'},ret:'a string with the result of the ping.'};
doc['Network']['set_adminPassword']={syn:'Changes the password for the \x22admin\x22 user.',lib:'YNetwork set_adminPassword',pro:'YNetwork <span id=pn>target</span> set_adminPassword <span id=pn>newval</span>',cmt:'<p>Changes the password for the \x22admin\x22 user. This password becomes instantly required to perform any change of the module state. If the specified value is an empty string, a password is not required anymore.</p>',par:{newval:'a string corresponding to the password for the \x22admin\x22 user'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackCredentials']={syn:'Changes the credentials required to connect to the callback address.',lib:'YNetwork set_callbackCredentials',pro:'YNetwork <span id=pn>target</span> set_callbackCredentials <span id=pn>newval</span>',cmt:'<p>Changes the credentials required to connect to the callback address. The credentials must be provided as returned by function <tt>get_callbackCredentials</tt>, in the form <tt>username:hash</tt>. The method used to compute the hash varies according to the the authentication scheme implemented by the callback, For Basic authentication, the hash is the MD5 of the string <tt>username:password</tt>. For Digest authentication, the hash is the MD5 of the string <tt>username:realm:password</tt>. For a simpler way to configure callback credentials, use function <tt>callbackLogin</tt> instead.</p>',par:{newval:'a string corresponding to the credentials required to connect to the callback address'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackEncoding']={syn:'Changes the encoding standard to use for representing notification values.',lib:'YNetwork set_callbackEncoding',pro:'YNetwork <span id=pn>target</span> set_callbackEncoding <span id=pn>newval</span>',cmt:'<p>Changes the encoding standard to use for representing notification values.</p>',par:{newval:'a value among <tt>FORM</tt>, <tt>JSON</tt>, <tt>JSON_ARRAY</tt>, <tt>CSV</tt>, <tt>YOCTO_API</tt>, <tt>JSON_NUM</tt>, <tt>EMONCMS</tt> and <tt>AZURE</tt> corresponding to the encoding standard to use for representing notification values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackMaxDelay']={syn:'Changes the maximum waiting time between two callback notifications, in seconds.',lib:'YNetwork set_callbackMaxDelay',pro:'YNetwork <span id=pn>target</span> set_callbackMaxDelay <span id=pn>newval</span>',cmt:'<p>Changes the maximum waiting time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the maximum waiting time between two callback notifications, in seconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackMethod']={syn:'Changes the HTTP method used to notify callbacks for significant state changes.',lib:'YNetwork set_callbackMethod',pro:'YNetwork <span id=pn>target</span> set_callbackMethod <span id=pn>newval</span>',cmt:'<p>Changes the HTTP method used to notify callbacks for significant state changes.</p>',par:{newval:'a value among <tt>POST</tt>, <tt>GET</tt> and <tt>PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackMinDelay']={syn:'Changes the minimum waiting time between two callback notifications, in seconds.',lib:'YNetwork set_callbackMinDelay',pro:'YNetwork <span id=pn>target</span> set_callbackMinDelay <span id=pn>newval</span>',cmt:'<p>Changes the minimum waiting time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the minimum waiting time between two callback notifications, in seconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_callbackUrl']={syn:'Changes the callback URL to notify significant state changes.',lib:'YNetwork set_callbackUrl',pro:'YNetwork <span id=pn>target</span> set_callbackUrl <span id=pn>newval</span>',cmt:'<p>Changes the callback URL to notify significant state changes.</p>',par:{newval:'a string corresponding to the callback URL to notify significant state changes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_defaultPage']={syn:'Changes the default HTML page returned by the hub.',lib:'YNetwork set_defaultPage',pro:'YNetwork <span id=pn>target</span> set_defaultPage <span id=pn>newval</span>',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible de change this page for file that has been uploaded on the hub.</p>',par:{newval:'a string corresponding to the default HTML page returned by the hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_discoverable']={syn:'Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'YNetwork set_discoverable',pro:'YNetwork <span id=pn>target</span> set_discoverable <span id=pn>newval</span>',cmt:'<p>Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_httpPort']={syn:'Changes the default HTML page returned by the hub.',lib:'YNetwork set_httpPort',pro:'YNetwork <span id=pn>target</span> set_httpPort <span id=pn>newval</span>',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible de change this page for file that has been uploaded on the hub.</p>',par:{newval:'an integer corresponding to the default HTML page returned by the hub'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_logicalName']={syn:'Changes the logical name of the network interface.',lib:'YNetwork set_logicalName',pro:'YNetwork <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the network interface.</p>',par:{newval:'a string corresponding to the logical name of the network interface.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_ntpServer']={syn:'Changes the IP address of the NTP server to be used by the module.',lib:'YNetwork set_ntpServer',pro:'YNetwork <span id=pn>target</span> set_ntpServer <span id=pn>newval</span>',cmt:'<p>Changes the IP address of the NTP server to be used by the module.</p>',par:{newval:'a string corresponding to the IP address of the NTP server to be used by the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_primaryDNS']={syn:'Changes the IP address of the primary name server to be used by the module.',lib:'YNetwork set_primaryDNS',pro:'YNetwork <span id=pn>target</span> set_primaryDNS <span id=pn>newval</span>',cmt:'<p>Changes the IP address of the primary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server.</p>',par:{newval:'a string corresponding to the IP address of the primary name server to be used by the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_secondaryDNS']={syn:'Changes the IP address of the secondary name server to be used by the module.',lib:'YNetwork set_secondaryDNS',pro:'YNetwork <span id=pn>target</span> set_secondaryDNS <span id=pn>newval</span>',cmt:'<p>Changes the IP address of the secondary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server.</p>',par:{newval:'a string corresponding to the IP address of the secondary name server to be used by the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_userPassword']={syn:'Changes the password for the \x22user\x22 user.',lib:'YNetwork set_userPassword',pro:'YNetwork <span id=pn>target</span> set_userPassword <span id=pn>newval</span>',cmt:'<p>Changes the password for the \x22user\x22 user. This password becomes instantly required to perform any use of the module. If the specified value is an empty string, a password is not required anymore.</p>',par:{newval:'a string corresponding to the password for the \x22user\x22 user'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['set_wwwWatchdogDelay']={syn:'Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'YNetwork set_wwwWatchdogDelay',pro:'YNetwork <span id=pn>target</span> set_wwwWatchdogDelay <span id=pn>newval</span>',cmt:'<p>Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss. The smallest valid non-zero timeout is 90 seconds.</p>',par:{newval:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Network']['useDHCP']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'YNetwork useDHCP',pro:'YNetwork <span id=pn>target</span> useDHCP <span id=pn>fallbackIpAddr</span> <span id=pn>fallbackSubnetMaskLen</span> <span id=pn>fallbackRouter</span>',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses the IP parameters specified to this function.</p>',par:{fallbackIpAddr:'fallback IP address, to be used when no DHCP reply is received',fallbackSubnetMaskLen:'fallback subnet mask length when no DHCP reply is received, as an integer (eg. 24 means 255.255.255.0)',fallbackRouter:'fallback router IP address, to be used when no DHCP reply is received'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Network']['useStaticIP']={syn:'Changes the configuration of the network interface to use a static IP address.',lib:'YNetwork useStaticIP',pro:'YNetwork <span id=pn>target</span> useStaticIP <span id=pn>ipAddress</span> <span id=pn>subnetMaskLen</span> <span id=pn>router</span>',cmt:'<p>Changes the configuration of the network interface to use a static IP address.</p>',par:{ipAddress:'device IP address',subnetMaskLen:'subnet mask length, as an integer (eg. 24 means 255.255.255.0)',router:'router IP address (default gateway)'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Network)
//--- (generated code: OsControl)
doc['OsControl']={'':{syn:'OS control',inc:'',cmt:'<p>The OScontrol object allows some control over the operating system running a VirtualHub. OsControl is available on the VirtualHub software only. This feature must be activated at the VirtualHub start up with -o option.</p>'}};
doc['OsControl']['get_advertisedValue']={syn:'Returns the current value of the OS control (no more than 6 characters).',lib:'YOsControl get_advertisedValue',pro:'YOsControl <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the OS control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the OS control (no more than 6 characters).',ext:''};
doc['OsControl']['get_logicalName']={syn:'Returns the logical name of the OS control.',lib:'YOsControl get_logicalName',pro:'YOsControl <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the OS control.</p>',ret:'a string corresponding to the logical name of the OS control.',ext:''};
doc['OsControl']['get_shutdownCountdown']={syn:'Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.',lib:'YOsControl get_shutdownCountdown',pro:'YOsControl <span id=pn>target</span> get_shutdownCountdown',cmt:'<p>Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled',ext:''};
doc['OsControl']['set_logicalName']={syn:'Changes the logical name of the OS control.',lib:'YOsControl set_logicalName',pro:'YOsControl <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the OS control.</p>',par:{newval:'a string corresponding to the logical name of the OS control.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['OsControl']['shutdown']={syn:'Schedules an OS shutdown after a given number of seconds.',lib:'YOsControl shutdown',pro:'YOsControl <span id=pn>target</span> shutdown <span id=pn>secBeforeShutDown</span>',cmt:'<p>Schedules an OS shutdown after a given number of seconds.</p>',par:{secBeforeShutDown:'number of seconds before shutdown'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: OsControl)
//--- (generated code: Power)
doc['Power']={'':{syn:'Power function interface',inc:'',cmt:'<p>The Yoctopuce class YPower allows you to read and configure Yoctopuce power sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to access the energy counter and the power factor.</p>'}};
doc['Power']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YPower calibrateFromPoints',pro:'YPower <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['get_advertisedValue']={syn:'Returns the current value of the electrical power sensor (no more than 6 characters).',lib:'YPower get_advertisedValue',pro:'YPower <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the electrical power sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the electrical power sensor (no more than 6 characters).',ext:''};
doc['Power']['get_cosPhi']={syn:'Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).',lib:'YPower get_cosPhi',pro:'YPower <span id=pn>target</span> get_cosPhi',cmt:'<p>Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).</p>',ret:'a floating point number corresponding to the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA)',ext:''};
doc['Power']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.',lib:'YPower get_currentRawValue',pro:'YPower <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number',ext:''};
doc['Power']['get_currentValue']={syn:'Returns the current value of the electrical power, in Watt, as a floating point number.',lib:'YPower get_currentValue',pro:'YPower <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the electrical power, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the electrical power, in Watt, as a floating point number',ext:''};
doc['Power']['get_highestValue']={syn:'Returns the maximal value observed for the electrical power since the device was started.',lib:'YPower get_highestValue',pro:'YPower <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the electrical power since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the electrical power since the device was started',ext:''};
doc['Power']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YPower get_logFrequency',pro:'YPower <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Power']['get_logicalName']={syn:'Returns the logical name of the electrical power sensor.',lib:'YPower get_logicalName',pro:'YPower <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the electrical power sensor.</p>',ret:'a string corresponding to the logical name of the electrical power sensor.',ext:''};
doc['Power']['get_lowestValue']={syn:'Returns the minimal value observed for the electrical power since the device was started.',lib:'YPower get_lowestValue',pro:'YPower <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the electrical power since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the electrical power since the device was started',ext:''};
doc['Power']['get_meter']={syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.',lib:'YPower get_meter',pro:'YPower <span id=pn>target</span> get_meter',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time. Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time',ext:''};
doc['Power']['get_meterTimer']={syn:'Returns the elapsed time since last energy counter reset, in seconds.',lib:'YPower get_meterTimer',pro:'YPower <span id=pn>target</span> get_meterTimer',cmt:'<p>Returns the elapsed time since last energy counter reset, in seconds.</p>',ret:'an integer corresponding to the elapsed time since last energy counter reset, in seconds',ext:''};
doc['Power']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YPower get_recordedData',pro:'YPower <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Power']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YPower get_reportFrequency',pro:'YPower <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Power']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YPower get_resolution',pro:'YPower <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Power']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YPower get_sensorState',pro:'YPower <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Power']['get_unit']={syn:'Returns the measuring unit for the electrical power.',lib:'YPower get_unit',pro:'YPower <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the electrical power.</p>',ret:'a string corresponding to the measuring unit for the electrical power',ext:''};
doc['Power']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YPower isSensorReady',pro:'YPower <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Power']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YPower loadCalibrationPoints',pro:'YPower <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['reset']={syn:'Resets the energy counter.',lib:'YPower reset',pro:'YPower <span id=pn>target</span> reset',cmt:'<p>Resets the energy counter.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YPower set_highestValue',pro:'YPower <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YPower set_logFrequency',pro:'YPower <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_logicalName']={syn:'Changes the logical name of the electrical power sensor.',lib:'YPower set_logicalName',pro:'YPower <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the electrical power sensor.</p>',par:{newval:'a string corresponding to the logical name of the electrical power sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YPower set_lowestValue',pro:'YPower <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YPower set_reportFrequency',pro:'YPower <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YPower set_resolution',pro:'YPower <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Power']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YPower startDataLogger',pro:'YPower <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Power']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YPower stopDataLogger',pro:'YPower <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Power)
//--- (generated code: RealTimeClock)
doc['RealTimeClock']={'':{syn:'Real Time Clock function interface',inc:'',cmt:'<p>The RealTimeClock function maintains and provides current date and time, even accross power cut lasting several days. It is the base for automated wake-up functions provided by the WakeUpScheduler. The current time may represent a local time as well as an UTC time, but no automatic time change will occur to account for daylight saving time.</p>'}};
doc['RealTimeClock']['get_advertisedValue']={syn:'Returns the current value of the clock (no more than 6 characters).',lib:'YRealTimeClock get_advertisedValue',pro:'YRealTimeClock <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the clock (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the clock (no more than 6 characters).',ext:''};
doc['RealTimeClock']['get_logicalName']={syn:'Returns the logical name of the clock.',lib:'YRealTimeClock get_logicalName',pro:'YRealTimeClock <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the clock.</p>',ret:'a string corresponding to the logical name of the clock.',ext:''};
doc['RealTimeClock']['get_timeSet']={syn:'Returns true if the clock has been set, and false otherwise.',lib:'YRealTimeClock get_timeSet',pro:'YRealTimeClock <span id=pn>target</span> get_timeSet',cmt:'<p>Returns true if the clock has been set, and false otherwise.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to true if the clock has been set, and false otherwise',ext:''};
doc['RealTimeClock']['get_unixTime']={syn:'Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).',lib:'YRealTimeClock get_unixTime',pro:'YRealTimeClock <span id=pn>target</span> get_unixTime',cmt:'<p>Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of elapsed seconds since Jan 1st, 1970)',ext:''};
doc['RealTimeClock']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'YRealTimeClock get_utcOffset',pro:'YRealTimeClock <span id=pn>target</span> get_utcOffset',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:''};
doc['RealTimeClock']['set_logicalName']={syn:'Changes the logical name of the clock.',lib:'YRealTimeClock set_logicalName',pro:'YRealTimeClock <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the clock.</p>',par:{newval:'a string corresponding to the logical name of the clock.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RealTimeClock']['set_unixTime']={syn:'Changes the current time.',lib:'YRealTimeClock set_unixTime',pro:'YRealTimeClock <span id=pn>target</span> set_unixTime <span id=pn>newval</span>',cmt:'<p>Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970). If current UTC time is known, utcOffset will be automatically adjusted for the new specified time.</p>',par:{newval:'an integer corresponding to the current time'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RealTimeClock']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'YRealTimeClock set_utcOffset',pro:'YRealTimeClock <span id=pn>target</span> set_utcOffset <span id=pn>newval</span>',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. If current UTC time is known, the current time will automatically be updated according to the selected time zone.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: RealTimeClock)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Relay function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to switch the relay state. This change is not persistent: the relay will automatically return to its idle position whenever power is lost or if the module is restarted. The library can also generate automatically short pulses of determined duration. On devices with two output for each relay (double throw), the two outputs are named A and B, with output A corresponding to the idle position (at power off) and the output B corresponding to the active state. If you prefer the alternate default state, simply switch your cables on the board.</p>'}};
doc['Relay']['delayedPulse']={syn:'Schedules a pulse.',lib:'YRelay delayedPulse',pro:'YRelay <span id=pn>target</span> delayedPulse <span id=pn>ms_delay</span> <span id=pn>ms_duration</span>',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['get_advertisedValue']={syn:'Returns the current value of the relay (no more than 6 characters).',lib:'YRelay get_advertisedValue',pro:'YRelay <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the relay (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the relay (no more than 6 characters).',ext:''};
doc['Relay']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'YRelay get_countdown',pro:'YRelay <span id=pn>target</span> get_countdown',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:''};
doc['Relay']['get_logicalName']={syn:'Returns the logical name of the relay.',lib:'YRelay get_logicalName',pro:'YRelay <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the relay.</p>',ret:'a string corresponding to the logical name of the relay.',ext:''};
doc['Relay']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'YRelay get_maxTimeOnStateA',pro:'YRelay <span id=pn>target</span> get_maxTimeOnStateA',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:''};
doc['Relay']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'YRelay get_maxTimeOnStateB',pro:'YRelay <span id=pn>target</span> get_maxTimeOnStateB',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:''};
doc['Relay']['get_output']={syn:'Returns the output state of the relays, when used as a simple switch (single throw).',lib:'YRelay get_output',pro:'YRelay <span id=pn>target</span> get_output',cmt:'<p>Returns the output state of the relays, when used as a simple switch (single throw).</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)',ext:''};
doc['Relay']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation.',lib:'YRelay get_pulseTimer',pro:'YRelay <span id=pn>target</span> get_pulseTimer',cmt:'<p>Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation',ext:''};
doc['Relay']['get_state']={syn:'Returns the state of the relays (A for the idle position, B for the active position).',lib:'YRelay get_state',pro:'YRelay <span id=pn>target</span> get_state',cmt:'<p>Returns the state of the relays (A for the idle position, B for the active position).</p>',ret:'either <tt>A</tt> or <tt>B</tt>, according to the state of the relays (A for the idle position, B for the active position)',ext:''};
doc['Relay']['get_stateAtPowerOn']={syn:'Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'YRelay get_stateAtPowerOn',pro:'YRelay <span id=pn>target</span> get_stateAtPowerOn',cmt:'<p>Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>UNCHANGED</tt>, <tt>A</tt> and <tt>B</tt> corresponding to the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:''};
doc['Relay']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'YRelay pulse',pro:'YRelay <span id=pn>target</span> pulse <span id=pn>ms_duration</span>',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_logicalName']={syn:'Changes the logical name of the relay.',lib:'YRelay set_logicalName',pro:'YRelay <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the relay.</p>',par:{newval:'a string corresponding to the logical name of the relay.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'YRelay set_maxTimeOnStateA',pro:'YRelay <span id=pn>target</span> set_maxTimeOnStateA <span id=pn>newval</span>',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'YRelay set_maxTimeOnStateB',pro:'YRelay <span id=pn>target</span> set_maxTimeOnStateB <span id=pn>newval</span>',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_output']={syn:'Changes the output state of the relays, when used as a simple switch (single throw).',lib:'YRelay set_output',pro:'YRelay <span id=pn>target</span> set_output <span id=pn>newval</span>',cmt:'<p>Changes the output state of the relays, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_state']={syn:'Changes the state of the relays (A for the idle position, B for the active position).',lib:'YRelay set_state',pro:'YRelay <span id=pn>target</span> set_state <span id=pn>newval</span>',cmt:'<p>Changes the state of the relays (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>A</tt> or <tt>B</tt>, according to the state of the relays (A for the idle position, B for the active position)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Relay']['set_stateAtPowerOn']={syn:'Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'YRelay set_stateAtPowerOn',pro:'YRelay <span id=pn>target</span> set_stateAtPowerOn <span id=pn>newval</span>',cmt:'<p>Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).</p>',par:{newval:'a value among <tt>UNCHANGED</tt>, <tt>A</tt> and <tt>B</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Relay)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Servo function interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you not only to move a servo to a given position, but also to specify the time interval in which the move should be performed. This makes it possible to synchronize two servos involved in a same move.</p>'}};
doc['Servo']['get_advertisedValue']={syn:'Returns the current value of the servo (no more than 6 characters).',lib:'YServo get_advertisedValue',pro:'YServo <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the servo (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the servo (no more than 6 characters).',ext:''};
doc['Servo']['get_enabled']={syn:'Returns the state of the servos.',lib:'YServo get_enabled',pro:'YServo <span id=pn>target</span> get_enabled',cmt:'<p>Returns the state of the servos.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the servos',ext:''};
doc['Servo']['get_enabledAtPowerOn']={syn:'Returns the servo signal generator state at power up.',lib:'YServo get_enabledAtPowerOn',pro:'YServo <span id=pn>target</span> get_enabledAtPowerOn',cmt:'<p>Returns the servo signal generator state at power up.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the servo signal generator state at power up',ext:''};
doc['Servo']['get_logicalName']={syn:'Returns the logical name of the servo.',lib:'YServo get_logicalName',pro:'YServo <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the servo.</p>',ret:'a string corresponding to the logical name of the servo.',ext:''};
doc['Servo']['get_neutral']={syn:'Returns the duration in microseconds of a neutral pulse for the servo.',lib:'YServo get_neutral',pro:'YServo <span id=pn>target</span> get_neutral',cmt:'<p>Returns the duration in microseconds of a neutral pulse for the servo.</p>',ret:'an integer corresponding to the duration in microseconds of a neutral pulse for the servo',ext:''};
doc['Servo']['get_position']={syn:'Returns the current servo position.',lib:'YServo get_position',pro:'YServo <span id=pn>target</span> get_position',cmt:'<p>Returns the current servo position.</p>',ret:'an integer corresponding to the current servo position',ext:''};
doc['Servo']['get_positionAtPowerOn']={syn:'Returns the servo position at device power up.',lib:'YServo get_positionAtPowerOn',pro:'YServo <span id=pn>target</span> get_positionAtPowerOn',cmt:'<p>Returns the servo position at device power up.</p>',ret:'an integer corresponding to the servo position at device power up',ext:''};
doc['Servo']['get_range']={syn:'Returns the current range of use of the servo.',lib:'YServo get_range',pro:'YServo <span id=pn>target</span> get_range',cmt:'<p>Returns the current range of use of the servo.</p>',ret:'an integer corresponding to the current range of use of the servo',ext:''};
doc['Servo']['move']={syn:'Performs a smooth move at constant speed toward a given position.',lib:'YServo move',pro:'YServo <span id=pn>target</span> move <span id=pn>target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth move at constant speed toward a given position.</p>',par:{target:'new position at the end of the move',ms_duration:'total duration of the move, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_enabled']={syn:'Stops or starts the servo.',lib:'YServo set_enabled',pro:'YServo <span id=pn>target</span> set_enabled <span id=pn>newval</span>',cmt:'<p>Stops or starts the servo.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_enabledAtPowerOn']={syn:'Configure the servo signal generator state at power up.',lib:'YServo set_enabledAtPowerOn',pro:'YServo <span id=pn>target</span> set_enabledAtPowerOn <span id=pn>newval</span>',cmt:'<p>Configure the servo signal generator state at power up.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_logicalName']={syn:'Changes the logical name of the servo.',lib:'YServo set_logicalName',pro:'YServo <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the servo.</p>',par:{newval:'a string corresponding to the logical name of the servo.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_neutral']={syn:'Changes the duration of the pulse corresponding to the neutral position of the servo.',lib:'YServo set_neutral',pro:'YServo <span id=pn>target</span> set_neutral <span id=pn>newval</span>',cmt:'<p>Changes the duration of the pulse corresponding to the neutral position of the servo. The duration is specified in microseconds, and the standard value is 1500 [us]. This setting makes it possible to shift the range of use of the servo. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the duration of the pulse corresponding to the neutral position of the servo'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_position']={syn:'Changes immediately the servo driving position.',lib:'YServo set_position',pro:'YServo <span id=pn>target</span> set_position <span id=pn>newval</span>',cmt:'<p>Changes immediately the servo driving position.</p>',par:{newval:'an integer corresponding to immediately the servo driving position'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_positionAtPowerOn']={syn:'Configure the servo position at device power up.',lib:'YServo set_positionAtPowerOn',pro:'YServo <span id=pn>target</span> set_positionAtPowerOn <span id=pn>newval</span>',cmt:'<p>Configure the servo position at device power up.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Servo']['set_range']={syn:'Changes the range of use of the servo, specified in per cents.',lib:'YServo set_range',pro:'YServo <span id=pn>target</span> set_range <span id=pn>newval</span>',cmt:'<p>Changes the range of use of the servo, specified in per cents. A range of 100% corresponds to a standard control signal, that varies from 1 [ms] to 2 [ms], When using a servo that supports a double range, from 0.5 [ms] to 2.5 [ms], you can select a range of 200%. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the range of use of the servo, specified in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Servo)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Voc function interface',inc:'',cmt:'<p>The Yoctopuce class YVoc allows you to read and configure Yoctopuce Volatile Organic Compound sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Voc']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YVoc calibrateFromPoints',pro:'YVoc <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['get_advertisedValue']={syn:'Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).',lib:'YVoc get_advertisedValue',pro:'YVoc <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Volatile Organic Compound sensor (no more than 6 characters).',ext:''};
doc['Voc']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'YVoc get_currentRawValue',pro:'YVoc <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:''};
doc['Voc']['get_currentValue']={syn:'Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.',lib:'YVoc get_currentValue',pro:'YVoc <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the estimated VOC concentration, in ppm (vol), as a floating point number',ext:''};
doc['Voc']['get_highestValue']={syn:'Returns the maximal value observed for the estimated VOC concentration since the device was started.',lib:'YVoc get_highestValue',pro:'YVoc <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the estimated VOC concentration since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the estimated VOC concentration since the device was started',ext:''};
doc['Voc']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YVoc get_logFrequency',pro:'YVoc <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Voc']['get_logicalName']={syn:'Returns the logical name of the Volatile Organic Compound sensor.',lib:'YVoc get_logicalName',pro:'YVoc <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Volatile Organic Compound sensor.',ext:''};
doc['Voc']['get_lowestValue']={syn:'Returns the minimal value observed for the estimated VOC concentration since the device was started.',lib:'YVoc get_lowestValue',pro:'YVoc <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the estimated VOC concentration since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the estimated VOC concentration since the device was started',ext:''};
doc['Voc']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YVoc get_recordedData',pro:'YVoc <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voc']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YVoc get_reportFrequency',pro:'YVoc <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Voc']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YVoc get_resolution',pro:'YVoc <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Voc']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YVoc get_sensorState',pro:'YVoc <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Voc']['get_unit']={syn:'Returns the measuring unit for the estimated VOC concentration.',lib:'YVoc get_unit',pro:'YVoc <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the estimated VOC concentration.</p>',ret:'a string corresponding to the measuring unit for the estimated VOC concentration',ext:''};
doc['Voc']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YVoc isSensorReady',pro:'YVoc <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Voc']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YVoc loadCalibrationPoints',pro:'YVoc <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YVoc set_highestValue',pro:'YVoc <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YVoc set_logFrequency',pro:'YVoc <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_logicalName']={syn:'Changes the logical name of the Volatile Organic Compound sensor.',lib:'YVoc set_logicalName',pro:'YVoc <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the Volatile Organic Compound sensor.</p>',par:{newval:'a string corresponding to the logical name of the Volatile Organic Compound sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YVoc set_lowestValue',pro:'YVoc <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YVoc set_reportFrequency',pro:'YVoc <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YVoc set_resolution',pro:'YVoc <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voc']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YVoc startDataLogger',pro:'YVoc <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Voc']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YVoc stopDataLogger',pro:'YVoc <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Voc)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Voltage function interface',inc:'',cmt:'<p>The Yoctopuce class YVoltage allows you to read and configure Yoctopuce voltage sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Voltage']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YVoltage calibrateFromPoints',pro:'YVoltage <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['get_advertisedValue']={syn:'Returns the current value of the voltage sensor (no more than 6 characters).',lib:'YVoltage get_advertisedValue',pro:'YVoltage <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the voltage sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage sensor (no more than 6 characters).',ext:''};
doc['Voltage']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.',lib:'YVoltage get_currentRawValue',pro:'YVoltage <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number',ext:''};
doc['Voltage']['get_currentValue']={syn:'Returns the current value of the voltage, in Volt, as a floating point number.',lib:'YVoltage get_currentValue',pro:'YVoltage <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the voltage, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the voltage, in Volt, as a floating point number',ext:''};
doc['Voltage']['get_highestValue']={syn:'Returns the maximal value observed for the voltage since the device was started.',lib:'YVoltage get_highestValue',pro:'YVoltage <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the voltage since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the voltage since the device was started',ext:''};
doc['Voltage']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YVoltage get_logFrequency',pro:'YVoltage <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Voltage']['get_logicalName']={syn:'Returns the logical name of the voltage sensor.',lib:'YVoltage get_logicalName',pro:'YVoltage <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the voltage sensor.</p>',ret:'a string corresponding to the logical name of the voltage sensor.',ext:''};
doc['Voltage']['get_lowestValue']={syn:'Returns the minimal value observed for the voltage since the device was started.',lib:'YVoltage get_lowestValue',pro:'YVoltage <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the voltage since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the voltage since the device was started',ext:''};
doc['Voltage']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YVoltage get_recordedData',pro:'YVoltage <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voltage']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YVoltage get_reportFrequency',pro:'YVoltage <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Voltage']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YVoltage get_resolution',pro:'YVoltage <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Voltage']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YVoltage get_sensorState',pro:'YVoltage <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Voltage']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'YVoltage get_unit',pro:'YVoltage <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:''};
doc['Voltage']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YVoltage isSensorReady',pro:'YVoltage <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Voltage']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YVoltage loadCalibrationPoints',pro:'YVoltage <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YVoltage set_highestValue',pro:'YVoltage <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YVoltage set_logFrequency',pro:'YVoltage <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_logicalName']={syn:'Changes the logical name of the voltage sensor.',lib:'YVoltage set_logicalName',pro:'YVoltage <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the voltage sensor.</p>',par:{newval:'a string corresponding to the logical name of the voltage sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YVoltage set_lowestValue',pro:'YVoltage <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YVoltage set_reportFrequency',pro:'YVoltage <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YVoltage set_resolution',pro:'YVoltage <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Voltage']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YVoltage startDataLogger',pro:'YVoltage <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Voltage']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YVoltage stopDataLogger',pro:'YVoltage <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Voltage)
//--- (generated code: WakeUpMonitor)
doc['WakeUpMonitor']={'':{syn:'WakeUpMonitor function interface',inc:'',cmt:'<p>The WakeUpMonitor function handles globally all wake-up sources, as well as automated sleep mode.</p>'}};
doc['WakeUpMonitor']['get_advertisedValue']={syn:'Returns the current value of the monitor (no more than 6 characters).',lib:'YWakeUpMonitor get_advertisedValue',pro:'YWakeUpMonitor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the monitor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the monitor (no more than 6 characters).',ext:''};
doc['WakeUpMonitor']['get_logicalName']={syn:'Returns the logical name of the monitor.',lib:'YWakeUpMonitor get_logicalName',pro:'YWakeUpMonitor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the monitor.</p>',ret:'a string corresponding to the logical name of the monitor.',ext:''};
doc['WakeUpMonitor']['get_powerDuration']={syn:'Returns the maximal wake up time (in seconds) before automatically going to sleep.',lib:'YWakeUpMonitor get_powerDuration',pro:'YWakeUpMonitor <span id=pn>target</span> get_powerDuration',cmt:'<p>Returns the maximal wake up time (in seconds) before automatically going to sleep.</p>',ret:'an integer corresponding to the maximal wake up time (in seconds) before automatically going to sleep',ext:''};
doc['WakeUpMonitor']['get_sleepCountdown']={syn:'Returns the delay before the next sleep period.',lib:'YWakeUpMonitor get_sleepCountdown',pro:'YWakeUpMonitor <span id=pn>target</span> get_sleepCountdown',cmt:'<p>Returns the delay before the next sleep period.</p>',ret:'an integer corresponding to the delay before the next sleep period',ext:''};
doc['WakeUpMonitor']['get_wakeUpReason']={syn:'Returns the latest wake up reason.',lib:'YWakeUpMonitor get_wakeUpReason',pro:'YWakeUpMonitor <span id=pn>target</span> get_wakeUpReason',cmt:'<p>Returns the latest wake up reason.</p>',ret:'a value among <tt>USBPOWER</tt>, <tt>EXTPOWER</tt>, <tt>ENDOFSLEEP</tt>, <tt>EXTSIG1</tt>, <tt>SCHEDULE1</tt> and <tt>SCHEDULE2</tt> corresponding to the latest wake up reason',ext:''};
doc['WakeUpMonitor']['resetSleepCountDown']={syn:'Resets the sleep countdown.',lib:'YWakeUpMonitor resetSleepCountDown',pro:'YWakeUpMonitor <span id=pn>target</span> resetSleepCountDown',cmt:'<p>Resets the sleep countdown.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_logicalName']={syn:'Changes the logical name of the monitor.',lib:'YWakeUpMonitor set_logicalName',pro:'YWakeUpMonitor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the monitor.</p>',par:{newval:'a string corresponding to the logical name of the monitor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['set_nextWakeUp']={syn:'Changes the days of the week when a wake up must take place.',lib:'YWakeUpMonitor set_nextWakeUp',pro:'YWakeUpMonitor <span id=pn>target</span> set_nextWakeUp <span id=pn>newval</span>',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['set_powerDuration']={syn:'Changes the maximal wake up time (seconds) before automatically going to sleep.',lib:'YWakeUpMonitor set_powerDuration',pro:'YWakeUpMonitor <span id=pn>target</span> set_powerDuration <span id=pn>newval</span>',cmt:'<p>Changes the maximal wake up time (seconds) before automatically going to sleep.</p>',par:{newval:'an integer corresponding to the maximal wake up time (seconds) before automatically going to sleep'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['set_sleepCountdown']={syn:'Changes the delay before the next sleep period.',lib:'YWakeUpMonitor set_sleepCountdown',pro:'YWakeUpMonitor <span id=pn>target</span> set_sleepCountdown <span id=pn>newval</span>',cmt:'<p>Changes the delay before the next sleep period.</p>',par:{newval:'an integer corresponding to the delay before the next sleep period'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['sleep']={syn:'Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'YWakeUpMonitor sleep',pro:'YWakeUpMonitor <span id=pn>target</span> sleep <span id=pn>secBeforeSleep</span>',cmt:'<p>Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.</p>',par:{secBeforeSleep:'number of seconds before going into sleep mode,'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['sleepFor']={syn:'Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'YWakeUpMonitor sleepFor',pro:'YWakeUpMonitor <span id=pn>target</span> sleepFor <span id=pn>secUntilWakeUp</span> <span id=pn>secBeforeSleep</span>',cmt:'<p>Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{secUntilWakeUp:'number of seconds before next wake up',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['sleepUntil']={syn:'Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'YWakeUpMonitor sleepUntil',pro:'YWakeUpMonitor <span id=pn>target</span> sleepUntil <span id=pn>wakeUpTime</span> <span id=pn>secBeforeSleep</span>',cmt:'<p>Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{wakeUpTime:'wake-up datetime (UNIX format)',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpMonitor']['wakeUp']={syn:'Forces a wake up.',lib:'YWakeUpMonitor wakeUp',pro:'YWakeUpMonitor <span id=pn>target</span> wakeUp',cmt:'<p>Forces a wake up.</p>'};
//--- (end of generated code: WakeUpMonitor)
//--- (generated code: WakeUpSchedule)
doc['WakeUpSchedule']={'':{syn:'WakeUpSchedule function interface',inc:'',cmt:'<p>The WakeUpSchedule function implements a wake up condition. The wake up time is specified as a set of months and/or days and/or hours and/or minutes when the wake up should happen.</p>'}};
doc['WakeUpSchedule']['get_advertisedValue']={syn:'Returns the current value of the wake up schedule (no more than 6 characters).',lib:'YWakeUpSchedule get_advertisedValue',pro:'YWakeUpSchedule <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the wake up schedule (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wake up schedule (no more than 6 characters).',ext:''};
doc['WakeUpSchedule']['get_hours']={syn:'Returns the hours scheduled for wake up.',lib:'YWakeUpSchedule get_hours',pro:'YWakeUpSchedule <span id=pn>target</span> get_hours',cmt:'<p>Returns the hours scheduled for wake up.</p>',ret:'an integer corresponding to the hours scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_logicalName']={syn:'Returns the logical name of the wake up schedule.',lib:'YWakeUpSchedule get_logicalName',pro:'YWakeUpSchedule <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the wake up schedule.</p>',ret:'a string corresponding to the logical name of the wake up schedule.',ext:''};
doc['WakeUpSchedule']['get_minutes']={syn:'Returns all the minutes of each hour that are scheduled for wake up.',lib:'YWakeUpSchedule get_minutes',pro:'YWakeUpSchedule <span id=pn>target</span> get_minutes',cmt:'<p>Returns all the minutes of each hour that are scheduled for wake up.</p>'};
doc['WakeUpSchedule']['get_minutesA']={syn:'Returns the minutes in the 00-29 interval of each hour scheduled for wake up.',lib:'YWakeUpSchedule get_minutesA',pro:'YWakeUpSchedule <span id=pn>target</span> get_minutesA',cmt:'<p>Returns the minutes in the 00-29 interval of each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 00-29 interval of each hour scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_minutesB']={syn:'Returns the minutes in the 30-59 intervalof each hour scheduled for wake up.',lib:'YWakeUpSchedule get_minutesB',pro:'YWakeUpSchedule <span id=pn>target</span> get_minutesB',cmt:'<p>Returns the minutes in the 30-59 intervalof each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 30-59 intervalof each hour scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_monthDays']={syn:'Returns the days of the month scheduled for wake up.',lib:'YWakeUpSchedule get_monthDays',pro:'YWakeUpSchedule <span id=pn>target</span> get_monthDays',cmt:'<p>Returns the days of the month scheduled for wake up.</p>',ret:'an integer corresponding to the days of the month scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_months']={syn:'Returns the months scheduled for wake up.',lib:'YWakeUpSchedule get_months',pro:'YWakeUpSchedule <span id=pn>target</span> get_months',cmt:'<p>Returns the months scheduled for wake up.</p>',ret:'an integer corresponding to the months scheduled for wake up',ext:''};
doc['WakeUpSchedule']['get_weekDays']={syn:'Returns the days of the week scheduled for wake up.',lib:'YWakeUpSchedule get_weekDays',pro:'YWakeUpSchedule <span id=pn>target</span> get_weekDays',cmt:'<p>Returns the days of the week scheduled for wake up.</p>',ret:'an integer corresponding to the days of the week scheduled for wake up',ext:''};
doc['WakeUpSchedule']['set_hours']={syn:'Changes the hours when a wake up must take place.',lib:'YWakeUpSchedule set_hours',pro:'YWakeUpSchedule <span id=pn>target</span> set_hours <span id=pn>newval</span>',cmt:'<p>Changes the hours when a wake up must take place.</p>',par:{newval:'an integer corresponding to the hours when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_logicalName']={syn:'Changes the logical name of the wake up schedule.',lib:'YWakeUpSchedule set_logicalName',pro:'YWakeUpSchedule <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the wake up schedule.</p>',par:{newval:'a string corresponding to the logical name of the wake up schedule.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_minutes']={syn:'Changes all the minutes where a wake up must take place.',lib:'YWakeUpSchedule set_minutes',pro:'YWakeUpSchedule <span id=pn>target</span> set_minutes <span id=pn>bitmap</span>',cmt:'<p>Changes all the minutes where a wake up must take place.</p>',par:{bitmap:'Minutes 00-59 of each hour scheduled for wake up.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_minutesA']={syn:'Changes the minutes in the 00-29 interval when a wake up must take place.',lib:'YWakeUpSchedule set_minutesA',pro:'YWakeUpSchedule <span id=pn>target</span> set_minutesA <span id=pn>newval</span>',cmt:'<p>Changes the minutes in the 00-29 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 00-29 interval when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_minutesB']={syn:'Changes the minutes in the 30-59 interval when a wake up must take place.',lib:'YWakeUpSchedule set_minutesB',pro:'YWakeUpSchedule <span id=pn>target</span> set_minutesB <span id=pn>newval</span>',cmt:'<p>Changes the minutes in the 30-59 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 30-59 interval when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_monthDays']={syn:'Changes the days of the month when a wake up must take place.',lib:'YWakeUpSchedule set_monthDays',pro:'YWakeUpSchedule <span id=pn>target</span> set_monthDays <span id=pn>newval</span>',cmt:'<p>Changes the days of the month when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the month when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_months']={syn:'Changes the months when a wake up must take place.',lib:'YWakeUpSchedule set_months',pro:'YWakeUpSchedule <span id=pn>target</span> set_months <span id=pn>newval</span>',cmt:'<p>Changes the months when a wake up must take place.</p>',par:{newval:'an integer corresponding to the months when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['WakeUpSchedule']['set_weekDays']={syn:'Changes the days of the week when a wake up must take place.',lib:'YWakeUpSchedule set_weekDays',pro:'YWakeUpSchedule <span id=pn>target</span> set_weekDays <span id=pn>newval</span>',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: WakeUpSchedule)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Watchdog function interface',inc:'',cmt:'<p>The watchog function works like a relay and can cause a brief power cut to an appliance after a preset delay to force this appliance to reset. The Watchdog must be called from time to time to reset the timer and prevent the appliance reset. The watchdog can be driven direcly with <i>pulse</i> and <i>delayedpulse</i> methods to switch off an appliance for a given duration.</p>'}};
doc['Watchdog']['delayedPulse']={syn:'Schedules a pulse.',lib:'YWatchdog delayedPulse',pro:'YWatchdog <span id=pn>target</span> delayedPulse <span id=pn>ms_delay</span> <span id=pn>ms_duration</span>',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['get_advertisedValue']={syn:'Returns the current value of the watchdog (no more than 6 characters).',lib:'YWatchdog get_advertisedValue',pro:'YWatchdog <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the watchdog (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the watchdog (no more than 6 characters).',ext:''};
doc['Watchdog']['get_autoStart']={syn:'Returns the watchdog runing state at module power on.',lib:'YWatchdog get_autoStart',pro:'YWatchdog <span id=pn>target</span> get_autoStart',cmt:'<p>Returns the watchdog runing state at module power on.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the watchdog runing state at module power on',ext:''};
doc['Watchdog']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'YWatchdog get_countdown',pro:'YWatchdog <span id=pn>target</span> get_countdown',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:''};
doc['Watchdog']['get_logicalName']={syn:'Returns the logical name of the watchdog.',lib:'YWatchdog get_logicalName',pro:'YWatchdog <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the watchdog.</p>',ret:'a string corresponding to the logical name of the watchdog.',ext:''};
doc['Watchdog']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'YWatchdog get_maxTimeOnStateA',pro:'YWatchdog <span id=pn>target</span> get_maxTimeOnStateA',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:''};
doc['Watchdog']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'YWatchdog get_maxTimeOnStateB',pro:'YWatchdog <span id=pn>target</span> get_maxTimeOnStateB',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:''};
doc['Watchdog']['get_output']={syn:'Returns the output state of the watchdog, when used as a simple switch (single throw).',lib:'YWatchdog get_output',pro:'YWatchdog <span id=pn>target</span> get_output',cmt:'<p>Returns the output state of the watchdog, when used as a simple switch (single throw).</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)',ext:''};
doc['Watchdog']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation.',lib:'YWatchdog get_pulseTimer',pro:'YWatchdog <span id=pn>target</span> get_pulseTimer',cmt:'<p>Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation',ext:''};
doc['Watchdog']['get_running']={syn:'Returns the watchdog running state.',lib:'YWatchdog get_running',pro:'YWatchdog <span id=pn>target</span> get_running',cmt:'<p>Returns the watchdog running state.</p>',ret:'either <tt>OFF</tt> or <tt>ON</tt>, according to the watchdog running state',ext:''};
doc['Watchdog']['get_state']={syn:'Returns the state of the watchdog (A for the idle position, B for the active position).',lib:'YWatchdog get_state',pro:'YWatchdog <span id=pn>target</span> get_state',cmt:'<p>Returns the state of the watchdog (A for the idle position, B for the active position).</p>',ret:'either <tt>A</tt> or <tt>B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)',ext:''};
doc['Watchdog']['get_stateAtPowerOn']={syn:'Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'YWatchdog get_stateAtPowerOn',pro:'YWatchdog <span id=pn>target</span> get_stateAtPowerOn',cmt:'<p>Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>UNCHANGED</tt>, <tt>A</tt> and <tt>B</tt> corresponding to the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:''};
doc['Watchdog']['get_triggerDelay']={syn:'Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.',lib:'YWatchdog get_triggerDelay',pro:'YWatchdog <span id=pn>target</span> get_triggerDelay',cmt:'<p>Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds',ext:''};
doc['Watchdog']['get_triggerDuration']={syn:'Returns the duration of resets caused by the watchdog, in milliseconds.',lib:'YWatchdog get_triggerDuration',pro:'YWatchdog <span id=pn>target</span> get_triggerDuration',cmt:'<p>Returns the duration of resets caused by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds',ext:''};
doc['Watchdog']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'YWatchdog pulse',pro:'YWatchdog <span id=pn>target</span> pulse <span id=pn>ms_duration</span>',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['resetWatchdog']={syn:'Resets the watchdog.',lib:'YWatchdog resetWatchdog',pro:'YWatchdog <span id=pn>target</span> resetWatchdog',cmt:'<p>Resets the watchdog. When the watchdog is running, this function must be called on a regular basis to prevent the watchog to trigger</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_autoStart']={syn:'Changes the watchdog runningsttae at module power on.',lib:'YWatchdog set_autoStart',pro:'YWatchdog <span id=pn>target</span> set_autoStart <span id=pn>newval</span>',cmt:'<p>Changes the watchdog runningsttae at module power on.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the watchdog runningsttae at module power on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_logicalName']={syn:'Changes the logical name of the watchdog.',lib:'YWatchdog set_logicalName',pro:'YWatchdog <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the watchdog.</p>',par:{newval:'a string corresponding to the logical name of the watchdog.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'YWatchdog set_maxTimeOnStateA',pro:'YWatchdog <span id=pn>target</span> set_maxTimeOnStateA <span id=pn>newval</span>',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'YWatchdog set_maxTimeOnStateB',pro:'YWatchdog <span id=pn>target</span> set_maxTimeOnStateB <span id=pn>newval</span>',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_output']={syn:'Changes the output state of the watchdog, when used as a simple switch (single throw).',lib:'YWatchdog set_output',pro:'YWatchdog <span id=pn>target</span> set_output <span id=pn>newval</span>',cmt:'<p>Changes the output state of the watchdog, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_running']={syn:'Changes the running state of the watchdog.',lib:'YWatchdog set_running',pro:'YWatchdog <span id=pn>target</span> set_running <span id=pn>newval</span>',cmt:'<p>Changes the running state of the watchdog.</p>',par:{newval:'either <tt>OFF</tt> or <tt>ON</tt>, according to the running state of the watchdog'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_state']={syn:'Changes the state of the watchdog (A for the idle position, B for the active position).',lib:'YWatchdog set_state',pro:'YWatchdog <span id=pn>target</span> set_state <span id=pn>newval</span>',cmt:'<p>Changes the state of the watchdog (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>A</tt> or <tt>B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_stateAtPowerOn']={syn:'Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'YWatchdog set_stateAtPowerOn',pro:'YWatchdog <span id=pn>target</span> set_stateAtPowerOn <span id=pn>newval</span>',cmt:'<p>Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).</p>',par:{newval:'a value among <tt>UNCHANGED</tt>, <tt>A</tt> and <tt>B</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_triggerDelay']={syn:'Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.',lib:'YWatchdog set_triggerDelay',pro:'YWatchdog <span id=pn>target</span> set_triggerDelay <span id=pn>newval</span>',cmt:'<p>Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the waiting delay before a reset is triggered by the watchdog, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Watchdog']['set_triggerDuration']={syn:'Changes the duration of resets caused by the watchdog, in milliseconds.',lib:'YWatchdog set_triggerDuration',pro:'YWatchdog <span id=pn>target</span> set_triggerDuration <span id=pn>newval</span>',cmt:'<p>Changes the duration of resets caused by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Watchdog)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Wireless function interface',inc:'',cmt:'<p>YWireless functions provides control over wireless network parameters and status for devices that are wireless-enabled.</p>'}};
doc['Wireless']['adhocNetwork']={syn:'Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point.',lib:'YWireless adhocNetwork',pro:'YWireless <span id=pn>target</span> adhocNetwork <span id=pn>ssid</span> <span id=pn>securityKey</span>',cmt:'<p>Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point. On the YoctoHub-Wireless-g, it is best to use softAPNetworkInstead(), which emulates an access point (Soft AP) which is more efficient and more widely supported than ad-hoc networks.</p><p> When a security key is specified for an ad-hoc network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Wireless']['get_advertisedValue']={syn:'Returns the current value of the wireless lan interface (no more than 6 characters).',lib:'YWireless get_advertisedValue',pro:'YWireless <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the wireless lan interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wireless lan interface (no more than 6 characters).',ext:''};
doc['Wireless']['get_channel']={syn:'Returns the 802.11 channel currently used, or 0 when the selected network has not been found.',lib:'YWireless get_channel',pro:'YWireless <span id=pn>target</span> get_channel',cmt:'<p>Returns the 802.11 channel currently used, or 0 when the selected network has not been found.</p>',ret:'an integer corresponding to the 802.11 channel currently used, or 0 when the selected network has not been found',ext:''};
doc['Wireless']['get_detectedWlans']={syn:'Returns a list of YWlanRecord objects that describe detected Wireless networks.',lib:'YWireless get_detectedWlans',pro:'YWireless <span id=pn>target</span> get_detectedWlans',cmt:'<p>Returns a list of YWlanRecord objects that describe detected Wireless networks. This list is not updated when the module is already connected to an acces point (infrastructure mode). To force an update of this list, <tt>adhocNetwork()</tt> must be called to disconnect the module from the current network. The returned list must be unallocated by the caller.</p>',ret:'a list of <tt>YWlanRecord</tt> objects, containing the SSID, channel, link quality and the type of security of the wireless network.',ext:''};
doc['Wireless']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'YWireless get_linkQuality',pro:'YWireless <span id=pn>target</span> get_linkQuality',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:''};
doc['Wireless']['get_logicalName']={syn:'Returns the logical name of the wireless lan interface.',lib:'YWireless get_logicalName',pro:'YWireless <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the wireless lan interface.</p>',ret:'a string corresponding to the logical name of the wireless lan interface.',ext:''};
doc['Wireless']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'YWireless get_message',pro:'YWireless <span id=pn>target</span> get_message',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:''};
doc['Wireless']['get_security']={syn:'Returns the security algorithm used by the selected wireless network.',lib:'YWireless get_security',pro:'YWireless <span id=pn>target</span> get_security',cmt:'<p>Returns the security algorithm used by the selected wireless network.</p>',ret:'a value among <tt>UNKNOWN</tt>, <tt>OPEN</tt>, <tt>WEP</tt>, <tt>WPA</tt> and <tt>WPA2</tt> corresponding to the security algorithm used by the selected wireless network',ext:''};
doc['Wireless']['get_ssid']={syn:'Returns the wireless network name (SSID).',lib:'YWireless get_ssid',pro:'YWireless <span id=pn>target</span> get_ssid',cmt:'<p>Returns the wireless network name (SSID).</p>',ret:'a string corresponding to the wireless network name (SSID)',ext:''};
doc['Wireless']['joinNetwork']={syn:'Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).',lib:'YWireless joinNetwork',pro:'YWireless <span id=pn>target</span> joinNetwork <span id=pn>ssid</span> <span id=pn>securityKey</span>',cmt:'<p>Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Wireless']['set_logicalName']={syn:'Changes the logical name of the wireless lan interface.',lib:'YWireless set_logicalName',pro:'YWireless <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the wireless lan interface.</p>',par:{newval:'a string corresponding to the logical name of the wireless lan interface.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Wireless']['softAPNetwork']={syn:'Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP).',lib:'YWireless softAPNetwork',pro:'YWireless <span id=pn>target</span> softAPNetwork <span id=pn>ssid</span> <span id=pn>securityKey</span>',cmt:'<p>Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP). This function can only be used with the YoctoHub-Wireless-g.</p><p> When a security key is specified for a SoftAP network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
//--- (end of generated code: Wireless)
//--- (generated code: Accelerometer)
doc['Accelerometer']={'':{syn:'Accelerometer function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Accelerometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YAccelerometer calibrateFromPoints',pro:'YAccelerometer <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['get_advertisedValue']={syn:'Returns the current value of the accelerometer (no more than 6 characters).',lib:'YAccelerometer get_advertisedValue',pro:'YAccelerometer <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the accelerometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the accelerometer (no more than 6 characters).',ext:''};
doc['Accelerometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.',lib:'YAccelerometer get_currentRawValue',pro:'YAccelerometer <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number',ext:''};
doc['Accelerometer']['get_currentValue']={syn:'Returns the current value of the acceleration, in g, as a floating point number.',lib:'YAccelerometer get_currentValue',pro:'YAccelerometer <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the acceleration, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the acceleration, in g, as a floating point number',ext:''};
doc['Accelerometer']['get_highestValue']={syn:'Returns the maximal value observed for the acceleration since the device was started.',lib:'YAccelerometer get_highestValue',pro:'YAccelerometer <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the acceleration since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the acceleration since the device was started',ext:''};
doc['Accelerometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YAccelerometer get_logFrequency',pro:'YAccelerometer <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Accelerometer']['get_logicalName']={syn:'Returns the logical name of the accelerometer.',lib:'YAccelerometer get_logicalName',pro:'YAccelerometer <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the accelerometer.</p>',ret:'a string corresponding to the logical name of the accelerometer.',ext:''};
doc['Accelerometer']['get_lowestValue']={syn:'Returns the minimal value observed for the acceleration since the device was started.',lib:'YAccelerometer get_lowestValue',pro:'YAccelerometer <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the acceleration since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the acceleration since the device was started',ext:''};
doc['Accelerometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YAccelerometer get_recordedData',pro:'YAccelerometer <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Accelerometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YAccelerometer get_reportFrequency',pro:'YAccelerometer <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Accelerometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YAccelerometer get_resolution',pro:'YAccelerometer <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Accelerometer']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YAccelerometer get_sensorState',pro:'YAccelerometer <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Accelerometer']['get_unit']={syn:'Returns the measuring unit for the acceleration.',lib:'YAccelerometer get_unit',pro:'YAccelerometer <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the acceleration.</p>',ret:'a string corresponding to the measuring unit for the acceleration',ext:''};
doc['Accelerometer']['get_xValue']={syn:'Returns the X component of the acceleration, as a floating point number.',lib:'YAccelerometer get_xValue',pro:'YAccelerometer <span id=pn>target</span> get_xValue',cmt:'<p>Returns the X component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the acceleration, as a floating point number',ext:''};
doc['Accelerometer']['get_yValue']={syn:'Returns the Y component of the acceleration, as a floating point number.',lib:'YAccelerometer get_yValue',pro:'YAccelerometer <span id=pn>target</span> get_yValue',cmt:'<p>Returns the Y component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the acceleration, as a floating point number',ext:''};
doc['Accelerometer']['get_zValue']={syn:'Returns the Z component of the acceleration, as a floating point number.',lib:'YAccelerometer get_zValue',pro:'YAccelerometer <span id=pn>target</span> get_zValue',cmt:'<p>Returns the Z component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the acceleration, as a floating point number',ext:''};
doc['Accelerometer']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YAccelerometer isSensorReady',pro:'YAccelerometer <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Accelerometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YAccelerometer loadCalibrationPoints',pro:'YAccelerometer <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YAccelerometer set_highestValue',pro:'YAccelerometer <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YAccelerometer set_logFrequency',pro:'YAccelerometer <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_logicalName']={syn:'Changes the logical name of the accelerometer.',lib:'YAccelerometer set_logicalName',pro:'YAccelerometer <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the accelerometer.</p>',par:{newval:'a string corresponding to the logical name of the accelerometer.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YAccelerometer set_lowestValue',pro:'YAccelerometer <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YAccelerometer set_reportFrequency',pro:'YAccelerometer <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YAccelerometer set_resolution',pro:'YAccelerometer <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Accelerometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YAccelerometer startDataLogger',pro:'YAccelerometer <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Accelerometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YAccelerometer stopDataLogger',pro:'YAccelerometer <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Accelerometer)
//--- (generated code: Magnetometer)
doc['Magnetometer']={'':{syn:'Magnetometer function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Magnetometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YMagnetometer calibrateFromPoints',pro:'YMagnetometer <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['get_advertisedValue']={syn:'Returns the current value of the magnetometer (no more than 6 characters).',lib:'YMagnetometer get_advertisedValue',pro:'YMagnetometer <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the magnetometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the magnetometer (no more than 6 characters).',ext:''};
doc['Magnetometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.',lib:'YMagnetometer get_currentRawValue',pro:'YMagnetometer <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number',ext:''};
doc['Magnetometer']['get_currentValue']={syn:'Returns the current value of the magnetic field, in mT, as a floating point number.',lib:'YMagnetometer get_currentValue',pro:'YMagnetometer <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the magnetic field, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the magnetic field, in mT, as a floating point number',ext:''};
doc['Magnetometer']['get_highestValue']={syn:'Returns the maximal value observed for the magnetic field since the device was started.',lib:'YMagnetometer get_highestValue',pro:'YMagnetometer <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the magnetic field since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the magnetic field since the device was started',ext:''};
doc['Magnetometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YMagnetometer get_logFrequency',pro:'YMagnetometer <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Magnetometer']['get_logicalName']={syn:'Returns the logical name of the magnetometer.',lib:'YMagnetometer get_logicalName',pro:'YMagnetometer <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the magnetometer.</p>',ret:'a string corresponding to the logical name of the magnetometer.',ext:''};
doc['Magnetometer']['get_lowestValue']={syn:'Returns the minimal value observed for the magnetic field since the device was started.',lib:'YMagnetometer get_lowestValue',pro:'YMagnetometer <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the magnetic field since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the magnetic field since the device was started',ext:''};
doc['Magnetometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YMagnetometer get_recordedData',pro:'YMagnetometer <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Magnetometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YMagnetometer get_reportFrequency',pro:'YMagnetometer <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Magnetometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YMagnetometer get_resolution',pro:'YMagnetometer <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Magnetometer']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YMagnetometer get_sensorState',pro:'YMagnetometer <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Magnetometer']['get_unit']={syn:'Returns the measuring unit for the magnetic field.',lib:'YMagnetometer get_unit',pro:'YMagnetometer <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the magnetic field.</p>',ret:'a string corresponding to the measuring unit for the magnetic field',ext:''};
doc['Magnetometer']['get_xValue']={syn:'Returns the X component of the magnetic field, as a floating point number.',lib:'YMagnetometer get_xValue',pro:'YMagnetometer <span id=pn>target</span> get_xValue',cmt:'<p>Returns the X component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the magnetic field, as a floating point number',ext:''};
doc['Magnetometer']['get_yValue']={syn:'Returns the Y component of the magnetic field, as a floating point number.',lib:'YMagnetometer get_yValue',pro:'YMagnetometer <span id=pn>target</span> get_yValue',cmt:'<p>Returns the Y component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the magnetic field, as a floating point number',ext:''};
doc['Magnetometer']['get_zValue']={syn:'Returns the Z component of the magnetic field, as a floating point number.',lib:'YMagnetometer get_zValue',pro:'YMagnetometer <span id=pn>target</span> get_zValue',cmt:'<p>Returns the Z component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the magnetic field, as a floating point number',ext:''};
doc['Magnetometer']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YMagnetometer isSensorReady',pro:'YMagnetometer <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Magnetometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YMagnetometer loadCalibrationPoints',pro:'YMagnetometer <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YMagnetometer set_highestValue',pro:'YMagnetometer <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YMagnetometer set_logFrequency',pro:'YMagnetometer <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_logicalName']={syn:'Changes the logical name of the magnetometer.',lib:'YMagnetometer set_logicalName',pro:'YMagnetometer <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the magnetometer.</p>',par:{newval:'a string corresponding to the logical name of the magnetometer.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YMagnetometer set_lowestValue',pro:'YMagnetometer <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YMagnetometer set_reportFrequency',pro:'YMagnetometer <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YMagnetometer set_resolution',pro:'YMagnetometer <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Magnetometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YMagnetometer startDataLogger',pro:'YMagnetometer <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Magnetometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YMagnetometer stopDataLogger',pro:'YMagnetometer <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Magnetometer)
//--- (generated code: RefFrame)
doc['RefFrame']={'':{syn:'Reference frame configuration',inc:'',cmt:'<p>This class is used to setup the base orientation of the Yocto-3D, so that the orientation functions, relative to the earth surface plane, use the proper reference frame. The class also implements a tridimensional sensor calibration process, which can compensate for local variations of standard gravity and improve the precision of the tilt sensors.</p>'}};
doc['RefFrame']['cancel3DCalibration']={syn:'Aborts the sensors tridimensional calibration process et restores normal settings.',lib:'YRefFrame cancel3DCalibration',pro:'YRefFrame <span id=pn>target</span> cancel3DCalibration',cmt:'<p>Aborts the sensors tridimensional calibration process et restores normal settings. On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['get_3DCalibrationHint']={syn:'Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'YRefFrame get_3DCalibrationHint',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationHint',cmt:'<p>Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationLogMsg']={syn:'Returns the latest log message from the calibration process.',lib:'YRefFrame get_3DCalibrationLogMsg',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationLogMsg',cmt:'<p>Returns the latest log message from the calibration process. When no new message is available, returns an empty string.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationProgress']={syn:'Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'YRefFrame get_3DCalibrationProgress',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationProgress',cmt:'<p>Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_3DCalibrationStage']={syn:'Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'YRefFrame get_3DCalibrationStage',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationStage',cmt:'<p>Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer, growing each time a calibration stage is completed.'};
doc['RefFrame']['get_3DCalibrationStageProgress']={syn:'Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'YRefFrame get_3DCalibrationStageProgress',pro:'YRefFrame <span id=pn>target</span> get_3DCalibrationStageProgress',cmt:'<p>Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_advertisedValue']={syn:'Returns the current value of the reference frame (no more than 6 characters).',lib:'YRefFrame get_advertisedValue',pro:'YRefFrame <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the reference frame (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the reference frame (no more than 6 characters).',ext:''};
doc['RefFrame']['get_bearing']={syn:'Returns the reference bearing used by the compass.',lib:'YRefFrame get_bearing',pro:'YRefFrame <span id=pn>target</span> get_bearing',cmt:'<p>Returns the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p>',ret:'a floating point number corresponding to the reference bearing used by the compass',ext:''};
doc['RefFrame']['get_logicalName']={syn:'Returns the logical name of the reference frame.',lib:'YRefFrame get_logicalName',pro:'YRefFrame <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the reference frame.</p>',ret:'a string corresponding to the logical name of the reference frame.',ext:''};
doc['RefFrame']['get_mountOrientation']={syn:'Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'YRefFrame get_mountOrientation',pro:'YRefFrame <span id=pn>target</span> get_mountOrientation',cmt:'<p>Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>TWELVE</tt>, <tt>THREE</tt>, <tt>SIX</tt>, <tt>NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.',ext:''};
doc['RefFrame']['get_mountPosition']={syn:'Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'YRefFrame get_mountPosition',pro:'YRefFrame <span id=pn>target</span> get_mountPosition',cmt:'<p>Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>BOTTOM</tt>, <tt>TOP</tt>, <tt>FRONT</tt>, <tt>RIGHT</tt>, <tt>REAR</tt>, <tt>LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',ext:''};
doc['RefFrame']['more3DCalibration']={syn:'Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>.',lib:'YRefFrame more3DCalibration',pro:'YRefFrame <span id=pn>target</span> more3DCalibration',cmt:'<p>Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>. This method should be called approximately 5 times per second, while positioning the device according to the instructions provided by method <tt>get_3DCalibrationHint</tt>. Note that the instructions change during the calibration process. On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['save3DCalibration']={syn:'Applies the sensors tridimensional calibration parameters that have just been computed.',lib:'YRefFrame save3DCalibration',pro:'YRefFrame <span id=pn>target</span> save3DCalibration',cmt:'<p>Applies the sensors tridimensional calibration parameters that have just been computed. On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['set_bearing']={syn:'Changes the reference bearing used by the compass.',lib:'YRefFrame set_bearing',pro:'YRefFrame <span id=pn>target</span> set_bearing <span id=pn>newval</span>',cmt:'<p>Changes the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here. For instance, if you setup as reference bearing the value of the earth magnetic declination, the compass will provide the orientation relative to the geographic North. Similarly, when the sensor is not mounted along the standard directions because it has an additional yaw angle, you can set this angle in the reference bearing so that the compass provides the expected natural direction.</p>',par:{newval:'a floating point number corresponding to the reference bearing used by the compass'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RefFrame']['set_logicalName']={syn:'Changes the logical name of the reference frame.',lib:'YRefFrame set_logicalName',pro:'YRefFrame <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the reference frame.</p>',par:{newval:'a string corresponding to the logical name of the reference frame.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['RefFrame']['set_mountPosition']={syn:'Changes the compass and tilt sensor frame of reference.',lib:'YRefFrame set_mountPosition',pro:'YRefFrame <span id=pn>target</span> set_mountPosition <span id=pn>position</span> <span id=pn>orientation</span>',cmt:'<p>Changes the compass and tilt sensor frame of reference. The magnetic compass and the tilt sensors (pitch and roll) naturally work in the plane parallel to the earth surface. In case the device is not installed upright and horizontally, you must select its reference orientation (parallel to the earth surface) so that the measures are made relative to this position.</p>',par:{position:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>BOTTOM</tt>, <tt>TOP</tt>, <tt>FRONT</tt>, <tt>RIGHT</tt>, <tt>REAR</tt>, <tt>LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',orientation:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.'}};
doc['RefFrame']['start3DCalibration']={syn:'Initiates the sensors tridimensional calibration process.',lib:'YRefFrame start3DCalibration',pro:'YRefFrame <span id=pn>target</span> start3DCalibration',cmt:'<p>Initiates the sensors tridimensional calibration process. This calibration is used at low level for inertial position estimation and to enhance the precision of the tilt sensors. After calling this method, the device should be moved according to the instructions provided by method <tt>get_3DCalibrationHint</tt>, and <tt>more3DCalibration</tt> should be invoked about 5 times per second. The calibration procedure is completed when the method <tt>get_3DCalibrationProgress</tt> returns 100. At this point, the computed calibration parameters can be applied using method <tt>save3DCalibration</tt>. The calibration process can be canceled at any time using method <tt>cancel3DCalibration</tt>. On failure, throws an exception or returns a negative error code.</p>'};
//--- (end of generated code: RefFrame)
//--- (generated code: Compass)
doc['Compass']={'':{syn:'Compass function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Compass']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YCompass calibrateFromPoints',pro:'YCompass <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['get_advertisedValue']={syn:'Returns the current value of the compass (no more than 6 characters).',lib:'YCompass get_advertisedValue',pro:'YCompass <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the compass (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the compass (no more than 6 characters).',ext:''};
doc['Compass']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'YCompass get_currentRawValue',pro:'YCompass <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:''};
doc['Compass']['get_currentValue']={syn:'Returns the current value of the relative bearing, in degrees, as a floating point number.',lib:'YCompass get_currentValue',pro:'YCompass <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the relative bearing, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the relative bearing, in degrees, as a floating point number',ext:''};
doc['Compass']['get_highestValue']={syn:'Returns the maximal value observed for the relative bearing since the device was started.',lib:'YCompass get_highestValue',pro:'YCompass <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the relative bearing since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the relative bearing since the device was started',ext:''};
doc['Compass']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YCompass get_logFrequency',pro:'YCompass <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Compass']['get_logicalName']={syn:'Returns the logical name of the compass.',lib:'YCompass get_logicalName',pro:'YCompass <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the compass.</p>',ret:'a string corresponding to the logical name of the compass.',ext:''};
doc['Compass']['get_lowestValue']={syn:'Returns the minimal value observed for the relative bearing since the device was started.',lib:'YCompass get_lowestValue',pro:'YCompass <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the relative bearing since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the relative bearing since the device was started',ext:''};
doc['Compass']['get_magneticHeading']={syn:'Returns the magnetic heading, regardless of the configured bearing.',lib:'YCompass get_magneticHeading',pro:'YCompass <span id=pn>target</span> get_magneticHeading',cmt:'<p>Returns the magnetic heading, regardless of the configured bearing.</p>',ret:'a floating point number corresponding to the magnetic heading, regardless of the configured bearing',ext:''};
doc['Compass']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YCompass get_recordedData',pro:'YCompass <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Compass']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YCompass get_reportFrequency',pro:'YCompass <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Compass']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YCompass get_resolution',pro:'YCompass <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Compass']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YCompass get_sensorState',pro:'YCompass <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Compass']['get_unit']={syn:'Returns the measuring unit for the relative bearing.',lib:'YCompass get_unit',pro:'YCompass <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the relative bearing.</p>',ret:'a string corresponding to the measuring unit for the relative bearing',ext:''};
doc['Compass']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YCompass isSensorReady',pro:'YCompass <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Compass']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YCompass loadCalibrationPoints',pro:'YCompass <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YCompass set_highestValue',pro:'YCompass <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YCompass set_logFrequency',pro:'YCompass <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_logicalName']={syn:'Changes the logical name of the compass.',lib:'YCompass set_logicalName',pro:'YCompass <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the compass.</p>',par:{newval:'a string corresponding to the logical name of the compass.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YCompass set_lowestValue',pro:'YCompass <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YCompass set_reportFrequency',pro:'YCompass <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YCompass set_resolution',pro:'YCompass <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Compass']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YCompass startDataLogger',pro:'YCompass <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Compass']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YCompass stopDataLogger',pro:'YCompass <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Compass)
//--- (generated code: Gyro)
doc['Gyro']={'':{syn:'Gyroscope function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Gyro']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YGyro calibrateFromPoints',pro:'YGyro <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['get_advertisedValue']={syn:'Returns the current value of the gyroscope (no more than 6 characters).',lib:'YGyro get_advertisedValue',pro:'YGyro <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the gyroscope (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the gyroscope (no more than 6 characters).',ext:''};
doc['Gyro']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.',lib:'YGyro get_currentRawValue',pro:'YGyro <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number',ext:''};
doc['Gyro']['get_currentValue']={syn:'Returns the current value of the angular velocity, in degrees per second, as a floating point number.',lib:'YGyro get_currentValue',pro:'YGyro <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the angular velocity, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the angular velocity, in degrees per second, as a floating point number',ext:''};
doc['Gyro']['get_heading']={syn:'Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_heading',pro:'YGyro <span id=pn>target</span> get_heading',cmt:'<p>Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the heading can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to heading in degrees, between 0 and 360.'};
doc['Gyro']['get_highestValue']={syn:'Returns the maximal value observed for the angular velocity since the device was started.',lib:'YGyro get_highestValue',pro:'YGyro <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the angular velocity since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the angular velocity since the device was started',ext:''};
doc['Gyro']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YGyro get_logFrequency',pro:'YGyro <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Gyro']['get_logicalName']={syn:'Returns the logical name of the gyroscope.',lib:'YGyro get_logicalName',pro:'YGyro <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the gyroscope.</p>',ret:'a string corresponding to the logical name of the gyroscope.',ext:''};
doc['Gyro']['get_lowestValue']={syn:'Returns the minimal value observed for the angular velocity since the device was started.',lib:'YGyro get_lowestValue',pro:'YGyro <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the angular velocity since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the angular velocity since the device was started',ext:''};
doc['Gyro']['get_pitch']={syn:'Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_pitch',pro:'YGyro <span id=pn>target</span> get_pitch',cmt:'<p>Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the pitch angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to pitch angle in degrees, between -90 and +90.'};
doc['Gyro']['get_quaternionW']={syn:'Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_quaternionW',pro:'YGyro <span id=pn>target</span> get_quaternionW',cmt:'<p>Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. </p>',ret:'a floating-point number corresponding to the <tt>w</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionX']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_quaternionX',pro:'YGyro <span id=pn>target</span> get_quaternionX',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with rotations on the roll axis.</p>',ret:'a floating-point number corresponding to the <tt>x</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionY']={syn:'Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_quaternionY',pro:'YGyro <span id=pn>target</span> get_quaternionY',cmt:'<p>Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>y</tt> component is mostly correlated with rotations on the pitch axis.</p>',ret:'a floating-point number corresponding to the <tt>y</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionZ']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_quaternionZ',pro:'YGyro <span id=pn>target</span> get_quaternionZ',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with changes of heading.</p>',ret:'a floating-point number corresponding to the <tt>z</tt> component of the quaternion.'};
doc['Gyro']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YGyro get_recordedData',pro:'YGyro <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Gyro']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YGyro get_reportFrequency',pro:'YGyro <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Gyro']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YGyro get_resolution',pro:'YGyro <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Gyro']['get_roll']={syn:'Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'YGyro get_roll',pro:'YGyro <span id=pn>target</span> get_roll',cmt:'<p>Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the roll angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to roll angle in degrees, between -180 and +180.'};
doc['Gyro']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YGyro get_sensorState',pro:'YGyro <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Gyro']['get_unit']={syn:'Returns the measuring unit for the angular velocity.',lib:'YGyro get_unit',pro:'YGyro <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the angular velocity.</p>',ret:'a string corresponding to the measuring unit for the angular velocity',ext:''};
doc['Gyro']['get_xValue']={syn:'Returns the angular velocity around the X axis of the device, as a floating point number.',lib:'YGyro get_xValue',pro:'YGyro <span id=pn>target</span> get_xValue',cmt:'<p>Returns the angular velocity around the X axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the X axis of the device, as a floating point number',ext:''};
doc['Gyro']['get_yValue']={syn:'Returns the angular velocity around the Y axis of the device, as a floating point number.',lib:'YGyro get_yValue',pro:'YGyro <span id=pn>target</span> get_yValue',cmt:'<p>Returns the angular velocity around the Y axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Y axis of the device, as a floating point number',ext:''};
doc['Gyro']['get_zValue']={syn:'Returns the angular velocity around the Z axis of the device, as a floating point number.',lib:'YGyro get_zValue',pro:'YGyro <span id=pn>target</span> get_zValue',cmt:'<p>Returns the angular velocity around the Z axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Z axis of the device, as a floating point number',ext:''};
doc['Gyro']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YGyro isSensorReady',pro:'YGyro <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Gyro']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YGyro loadCalibrationPoints',pro:'YGyro <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YGyro set_highestValue',pro:'YGyro <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YGyro set_logFrequency',pro:'YGyro <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_logicalName']={syn:'Changes the logical name of the gyroscope.',lib:'YGyro set_logicalName',pro:'YGyro <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the gyroscope.</p>',par:{newval:'a string corresponding to the logical name of the gyroscope.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YGyro set_lowestValue',pro:'YGyro <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YGyro set_reportFrequency',pro:'YGyro <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YGyro set_resolution',pro:'YGyro <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gyro']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YGyro startDataLogger',pro:'YGyro <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Gyro']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YGyro stopDataLogger',pro:'YGyro <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Gyro)
//--- (generated code: Tilt)
doc['Tilt']={'':{syn:'Tilt function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Tilt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YTilt calibrateFromPoints',pro:'YTilt <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['get_advertisedValue']={syn:'Returns the current value of the tilt sensor (no more than 6 characters).',lib:'YTilt get_advertisedValue',pro:'YTilt <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the tilt sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the tilt sensor (no more than 6 characters).',ext:''};
doc['Tilt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'YTilt get_currentRawValue',pro:'YTilt <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:''};
doc['Tilt']['get_currentValue']={syn:'Returns the current value of the inclination, in degrees, as a floating point number.',lib:'YTilt get_currentValue',pro:'YTilt <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the inclination, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the inclination, in degrees, as a floating point number',ext:''};
doc['Tilt']['get_highestValue']={syn:'Returns the maximal value observed for the inclination since the device was started.',lib:'YTilt get_highestValue',pro:'YTilt <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the inclination since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the inclination since the device was started',ext:''};
doc['Tilt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YTilt get_logFrequency',pro:'YTilt <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Tilt']['get_logicalName']={syn:'Returns the logical name of the tilt sensor.',lib:'YTilt get_logicalName',pro:'YTilt <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the tilt sensor.</p>',ret:'a string corresponding to the logical name of the tilt sensor.',ext:''};
doc['Tilt']['get_lowestValue']={syn:'Returns the minimal value observed for the inclination since the device was started.',lib:'YTilt get_lowestValue',pro:'YTilt <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the inclination since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the inclination since the device was started',ext:''};
doc['Tilt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YTilt get_recordedData',pro:'YTilt <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Tilt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YTilt get_reportFrequency',pro:'YTilt <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Tilt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YTilt get_resolution',pro:'YTilt <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Tilt']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YTilt get_sensorState',pro:'YTilt <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Tilt']['get_unit']={syn:'Returns the measuring unit for the inclination.',lib:'YTilt get_unit',pro:'YTilt <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the inclination.</p>',ret:'a string corresponding to the measuring unit for the inclination',ext:''};
doc['Tilt']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YTilt isSensorReady',pro:'YTilt <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Tilt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YTilt loadCalibrationPoints',pro:'YTilt <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YTilt set_highestValue',pro:'YTilt <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YTilt set_logFrequency',pro:'YTilt <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_logicalName']={syn:'Changes the logical name of the tilt sensor.',lib:'YTilt set_logicalName',pro:'YTilt <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the tilt sensor.</p>',par:{newval:'a string corresponding to the logical name of the tilt sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YTilt set_lowestValue',pro:'YTilt <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YTilt set_reportFrequency',pro:'YTilt <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YTilt set_resolution',pro:'YTilt <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Tilt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YTilt startDataLogger',pro:'YTilt <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Tilt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YTilt stopDataLogger',pro:'YTilt <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Tilt)
//--- (generated code: PwmOutput)
doc['PwmOutput']={'':{syn:'PwmOutput function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to configure, start, and stop the PWM.</p>'}};
doc['PwmOutput']['dutyCycleMove']={syn:'Performs a smooth change of the pulse duration toward a given value.',lib:'YPwmOutput dutyCycleMove',pro:'YPwmOutput <span id=pn>target</span> dutyCycleMove <span id=pn>target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth change of the pulse duration toward a given value.</p>',par:{target:'new duty cycle at the end of the transition (floating-point number, between 0 and 1)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['get_advertisedValue']={syn:'Returns the current value of the PWM (no more than 6 characters).',lib:'YPwmOutput get_advertisedValue',pro:'YPwmOutput <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the PWM (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM (no more than 6 characters).',ext:''};
doc['PwmOutput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'YPwmOutput get_dutyCycle',pro:'YPwmOutput <span id=pn>target</span> get_dutyCycle',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:''};
doc['PwmOutput']['get_enabled']={syn:'Returns the state of the PWMs.',lib:'YPwmOutput get_enabled',pro:'YPwmOutput <span id=pn>target</span> get_enabled',cmt:'<p>Returns the state of the PWMs.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the PWMs',ext:''};
doc['PwmOutput']['get_enabledAtPowerOn']={syn:'Returns the state of the PWM at device power on.',lib:'YPwmOutput get_enabledAtPowerOn',pro:'YPwmOutput <span id=pn>target</span> get_enabledAtPowerOn',cmt:'<p>Returns the state of the PWM at device power on.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the PWM at device power on',ext:''};
doc['PwmOutput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'YPwmOutput get_frequency',pro:'YPwmOutput <span id=pn>target</span> get_frequency',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:''};
doc['PwmOutput']['get_logicalName']={syn:'Returns the logical name of the PWM.',lib:'YPwmOutput get_logicalName',pro:'YPwmOutput <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the PWM.</p>',ret:'a string corresponding to the logical name of the PWM.',ext:''};
doc['PwmOutput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'YPwmOutput get_period',pro:'YPwmOutput <span id=pn>target</span> get_period',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:''};
doc['PwmOutput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'YPwmOutput get_pulseDuration',pro:'YPwmOutput <span id=pn>target</span> get_pulseDuration',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:''};
doc['PwmOutput']['pulseDurationMove']={syn:'Performs a smooth transistion of the pulse duration toward a given value.',lib:'YPwmOutput pulseDurationMove',pro:'YPwmOutput <span id=pn>target</span> pulseDurationMove <span id=pn>ms_target</span> <span id=pn>ms_duration</span>',cmt:'<p>Performs a smooth transistion of the pulse duration toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{ms_target:'new pulse duration at the end of the transition (floating-point number, representing the pulse duration in milliseconds)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['PwmOutput']['set_dutyCycle']={syn:'Changes the PWM duty cycle, in per cents.',lib:'YPwmOutput set_dutyCycle',pro:'YPwmOutput <span id=pn>target</span> set_dutyCycle <span id=pn>newval</span>',cmt:'<p>Changes the PWM duty cycle, in per cents.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_dutyCycleAtPowerOn']={syn:'Changes the PWM duty cycle at device power on.',lib:'YPwmOutput set_dutyCycleAtPowerOn',pro:'YPwmOutput <span id=pn>target</span> set_dutyCycleAtPowerOn <span id=pn>newval</span>',cmt:'<p>Changes the PWM duty cycle at device power on.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle at device power on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_enabled']={syn:'Stops or starts the PWM.',lib:'YPwmOutput set_enabled',pro:'YPwmOutput <span id=pn>target</span> set_enabled <span id=pn>newval</span>',cmt:'<p>Stops or starts the PWM.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_enabledAtPowerOn']={syn:'Changes the state of the PWM at device power on.',lib:'YPwmOutput set_enabledAtPowerOn',pro:'YPwmOutput <span id=pn>target</span> set_enabledAtPowerOn <span id=pn>newval</span>',cmt:'<p>Changes the state of the PWM at device power on.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the PWM at device power on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_frequency']={syn:'Changes the PWM frequency.',lib:'YPwmOutput set_frequency',pro:'YPwmOutput <span id=pn>target</span> set_frequency <span id=pn>newval</span>',cmt:'<p>Changes the PWM frequency. The duty cycle is kept unchanged thanks to an automatic pulse width change.</p>',par:{newval:'a floating point number corresponding to the PWM frequency'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_logicalName']={syn:'Changes the logical name of the PWM.',lib:'YPwmOutput set_logicalName',pro:'YPwmOutput <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the PWM.</p>',par:{newval:'a string corresponding to the logical name of the PWM.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_period']={syn:'Changes the PWM period in milliseconds.',lib:'YPwmOutput set_period',pro:'YPwmOutput <span id=pn>target</span> set_period <span id=pn>newval</span>',cmt:'<p>Changes the PWM period in milliseconds.</p>',par:{newval:'a floating point number corresponding to the PWM period in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmOutput']['set_pulseDuration']={syn:'Changes the PWM pulse length, in milliseconds.',lib:'YPwmOutput set_pulseDuration',pro:'YPwmOutput <span id=pn>target</span> set_pulseDuration <span id=pn>newval</span>',cmt:'<p>Changes the PWM pulse length, in milliseconds. A pulse length cannot be longer than period, otherwise it is truncated.</p>',par:{newval:'a floating point number corresponding to the PWM pulse length, in milliseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: PwmOutput)
//--- (generated code: PwmPowerSource)
doc['PwmPowerSource']={'':{syn:'PwmPowerSource function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to configure the voltage source used by all PWM on the same device.</p>'}};
doc['PwmPowerSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'YPwmPowerSource get_advertisedValue',pro:'YPwmPowerSource <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters).',ext:''};
doc['PwmPowerSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'YPwmPowerSource get_logicalName',pro:'YPwmPowerSource <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source.',ext:''};
doc['PwmPowerSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'YPwmPowerSource set_logicalName',pro:'YPwmPowerSource <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the voltage source.</p>',par:{newval:'a string corresponding to the logical name of the voltage source.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmPowerSource']['set_powerMode']={syn:'Changes the PWM power source.',lib:'YPwmPowerSource set_powerMode',pro:'YPwmPowerSource <span id=pn>target</span> set_powerMode <span id=pn>newval</span>',cmt:'<p>Changes the PWM power source. PWM can use isolated 5V from USB, isolated 3V from USB or voltage from an external power source. The PWM can also work in open drain mode. In that mode, the PWM actively pulls the line down. Warning: this setting is common to all PWM on the same device. If you change that parameter, all PWM located on the same device are affected.</p>',par:{newval:'a value among <tt>USB_5V</tt>, <tt>USB_3V</tt>, <tt>EXT_V</tt> and <tt>OPNDRN</tt> corresponding to the PWM power source'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: PwmPowerSource)
//--- (generated code: Qt)
doc['Qt']={'':{syn:'Quaternion interface',inc:'',cmt:'<p>The Yoctopuce API YQt class provides direct access to the Yocto3D attitude estimation using a quaternion. It is usually not needed to use the YQt class directly, as the YGyro class provides a more convenient higher-level interface.</p>'}};
doc['Qt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YSensor calibrateFromPoints',pro:'YSensor <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['get_advertisedValue']={syn:'Returns the current value of the quaternion component (no more than 6 characters).',lib:'YSensor get_advertisedValue',pro:'YSensor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the quaternion component (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quaternion component (no more than 6 characters).',ext:''};
doc['Qt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.',lib:'YSensor get_currentRawValue',pro:'YSensor <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number',ext:''};
doc['Qt']['get_currentValue']={syn:'Returns the current value of the value, in units, as a floating point number.',lib:'YSensor get_currentValue',pro:'YSensor <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the value, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the value, in units, as a floating point number',ext:''};
doc['Qt']['get_highestValue']={syn:'Returns the maximal value observed for the value since the device was started.',lib:'YSensor get_highestValue',pro:'YSensor <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the value since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the value since the device was started',ext:''};
doc['Qt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YSensor get_logFrequency',pro:'YSensor <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Qt']['get_logicalName']={syn:'Returns the logical name of the quaternion component.',lib:'YSensor get_logicalName',pro:'YSensor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the quaternion component.</p>',ret:'a string corresponding to the logical name of the quaternion component.',ext:''};
doc['Qt']['get_lowestValue']={syn:'Returns the minimal value observed for the value since the device was started.',lib:'YSensor get_lowestValue',pro:'YSensor <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the value since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the value since the device was started',ext:''};
doc['Qt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YSensor get_recordedData',pro:'YSensor <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Qt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YSensor get_reportFrequency',pro:'YSensor <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Qt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YSensor get_resolution',pro:'YSensor <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Qt']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YSensor get_sensorState',pro:'YSensor <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Qt']['get_unit']={syn:'Returns the measuring unit for the value.',lib:'YSensor get_unit',pro:'YSensor <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the value.</p>',ret:'a string corresponding to the measuring unit for the value',ext:''};
doc['Qt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YSensor loadCalibrationPoints',pro:'YSensor <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YSensor set_highestValue',pro:'YSensor <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YSensor set_logFrequency',pro:'YSensor <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_logicalName']={syn:'Changes the logical name of the quaternion component.',lib:'YSensor set_logicalName',pro:'YSensor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the quaternion component.</p>',par:{newval:'a string corresponding to the logical name of the quaternion component.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YSensor set_lowestValue',pro:'YSensor <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YSensor set_reportFrequency',pro:'YSensor <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YSensor set_resolution',pro:'YSensor <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Qt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YSensor startDataLogger',pro:'YSensor <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Qt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YSensor stopDataLogger',pro:'YSensor <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Qt)
//--- (generated code: Altitude)
doc['Altitude']={'':{syn:'Altitude function interface',inc:'',cmt:'<p>The Yoctopuce class YAltitude allows you to read and configure Yoctopuce altitude sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to configure the barometric pressure adjusted to sea level (QNH) for barometric sensors.</p>'}};
doc['Altitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YAltitude calibrateFromPoints',pro:'YAltitude <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['get_advertisedValue']={syn:'Returns the current value of the altimeter (no more than 6 characters).',lib:'YAltitude get_advertisedValue',pro:'YAltitude <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the altimeter (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the altimeter (no more than 6 characters).',ext:''};
doc['Altitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.',lib:'YAltitude get_currentRawValue',pro:'YAltitude <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number',ext:''};
doc['Altitude']['get_currentValue']={syn:'Returns the current value of the altitude, in meters, as a floating point number.',lib:'YAltitude get_currentValue',pro:'YAltitude <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the altitude, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the altitude, in meters, as a floating point number',ext:''};
doc['Altitude']['get_highestValue']={syn:'Returns the maximal value observed for the altitude since the device was started.',lib:'YAltitude get_highestValue',pro:'YAltitude <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the altitude since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the altitude since the device was started',ext:''};
doc['Altitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YAltitude get_logFrequency',pro:'YAltitude <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Altitude']['get_logicalName']={syn:'Returns the logical name of the altimeter.',lib:'YAltitude get_logicalName',pro:'YAltitude <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the altimeter.</p>',ret:'a string corresponding to the logical name of the altimeter.',ext:''};
doc['Altitude']['get_lowestValue']={syn:'Returns the minimal value observed for the altitude since the device was started.',lib:'YAltitude get_lowestValue',pro:'YAltitude <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the altitude since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the altitude since the device was started',ext:''};
doc['Altitude']['get_qnh']={syn:'Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'YAltitude get_qnh',pro:'YAltitude <span id=pn>target</span> get_qnh',cmt:'<p>Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH).</p>',ret:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)',ext:''};
doc['Altitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YAltitude get_recordedData',pro:'YAltitude <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Altitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YAltitude get_reportFrequency',pro:'YAltitude <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Altitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YAltitude get_resolution',pro:'YAltitude <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Altitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YAltitude get_sensorState',pro:'YAltitude <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Altitude']['get_technology']={syn:'Returns the technology used by the sesnor to compute altitude.',lib:'YAltitude get_technology',pro:'YAltitude <span id=pn>target</span> get_technology',cmt:'<p>Returns the technology used by the sesnor to compute altitude. Possibles values are \x22barometric\x22 and \x22gps\x22</p>',ret:'a string corresponding to the technology used by the sesnor to compute altitude',ext:''};
doc['Altitude']['get_unit']={syn:'Returns the measuring unit for the altitude.',lib:'YAltitude get_unit',pro:'YAltitude <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the altitude.</p>',ret:'a string corresponding to the measuring unit for the altitude',ext:''};
doc['Altitude']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YAltitude isSensorReady',pro:'YAltitude <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Altitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YAltitude loadCalibrationPoints',pro:'YAltitude <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_currentValue']={syn:'Changes the current estimated altitude.',lib:'YAltitude set_currentValue',pro:'YAltitude <span id=pn>target</span> set_currentValue <span id=pn>newval</span>',cmt:'<p>Changes the current estimated altitude. This allows to compensate for ambient pressure variations and to work in relative mode.</p>',par:{newval:'a floating point number corresponding to the current estimated altitude'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YAltitude set_highestValue',pro:'YAltitude <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YAltitude set_logFrequency',pro:'YAltitude <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_logicalName']={syn:'Changes the logical name of the altimeter.',lib:'YAltitude set_logicalName',pro:'YAltitude <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the altimeter.</p>',par:{newval:'a string corresponding to the logical name of the altimeter.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YAltitude set_lowestValue',pro:'YAltitude <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_qnh']={syn:'Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'YAltitude set_qnh',pro:'YAltitude <span id=pn>target</span> set_qnh <span id=pn>newval</span>',cmt:'<p>Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH). This enables you to compensate for atmospheric pressure changes due to weather conditions.</p>',par:{newval:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YAltitude set_reportFrequency',pro:'YAltitude <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YAltitude set_resolution',pro:'YAltitude <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Altitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YAltitude startDataLogger',pro:'YAltitude <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Altitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YAltitude stopDataLogger',pro:'YAltitude <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Altitude)
//--- (generated code: Motor)
doc['Motor']={'':{syn:'Motor function interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to drive the power sent to the motor to make it turn both ways, but also to drive accelerations and decelerations. The motor will then accelerate automatically: you will not have to monitor it. The API also allows to slow down the motor by shortening its terminals: the motor will then act as an electromagnetic brake.</p>'}};
doc['Motor']['brakingForceMove']={syn:'Changes progressively the braking force applied to the motor for a specific duration.',lib:'YMotor brakingForceMove',pro:'YMotor <span id=pn>target</span> brakingForceMove <span id=pn>targetPower</span> <span id=pn>delay</span>',cmt:'<p>Changes progressively the braking force applied to the motor for a specific duration.</p>',par:{targetPower:'desired braking force, in percents',delay:'duration (in ms) of the transition'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['drivingForceMove']={syn:'Changes progressively the power sent to the moteur for a specific duration.',lib:'YMotor drivingForceMove',pro:'YMotor <span id=pn>target</span> drivingForceMove <span id=pn>targetPower</span> <span id=pn>delay</span>',cmt:'<p>Changes progressively the power sent to the moteur for a specific duration.</p>',par:{targetPower:'desired motor power, in percents (between -100% and +100%)',delay:'duration (in ms) of the transition'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['get_advertisedValue']={syn:'Returns the current value of the motor (no more than 6 characters).',lib:'YMotor get_advertisedValue',pro:'YMotor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the motor (no more than 6 characters).',ext:''};
doc['Motor']['get_brakingForce']={syn:'Returns the braking force applied to the motor, as a percentage.',lib:'YMotor get_brakingForce',pro:'YMotor <span id=pn>target</span> get_brakingForce',cmt:'<p>Returns the braking force applied to the motor, as a percentage. The value 0 corresponds to no braking (free wheel).</p>',ret:'a floating point number corresponding to the braking force applied to the motor, as a percentage',ext:''};
doc['Motor']['get_cutOffVoltage']={syn:'Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'YMotor get_cutOffVoltage',pro:'YMotor <span id=pn>target</span> get_cutOffVoltage',cmt:'<p>Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevents damage to a battery that can occur when drawing current from an \x22empty\x22 battery.</p>',ret:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw',ext:''};
doc['Motor']['get_drivingForce']={syn:'Returns the power sent to the motor, as a percentage between -100% and +100%.',lib:'YMotor get_drivingForce',pro:'YMotor <span id=pn>target</span> get_drivingForce',cmt:'<p>Returns the power sent to the motor, as a percentage between -100% and +100%.</p>',ret:'a floating point number corresponding to the power sent to the motor, as a percentage between -100% and +100%',ext:''};
doc['Motor']['get_failSafeTimeout']={syn:'Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'YMotor get_failSafeTimeout',pro:'YMotor <span id=pn>target</span> get_failSafeTimeout',cmt:'<p>Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',ret:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process',ext:''};
doc['Motor']['get_frequency']={syn:'Returns the PWM frequency used to control the motor.',lib:'YMotor get_frequency',pro:'YMotor <span id=pn>target</span> get_frequency',cmt:'<p>Returns the PWM frequency used to control the motor.</p>',ret:'a floating point number corresponding to the PWM frequency used to control the motor',ext:''};
doc['Motor']['get_logicalName']={syn:'Returns the logical name of the motor.',lib:'YMotor get_logicalName',pro:'YMotor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the motor.</p>',ret:'a string corresponding to the logical name of the motor.',ext:''};
doc['Motor']['get_motorStatus']={syn:'Return the controller state.',lib:'YMotor get_motorStatus',pro:'YMotor <span id=pn>target</span> get_motorStatus',cmt:'<p>Return the controller state. Possible states are: IDLE when the motor is stopped/in free wheel, ready to start; FORWD when the controller is driving the motor forward; BACKWD when the controller is driving the motor backward; BRAKE when the controller is braking; LOVOLT when the controller has detected a low voltage condition; HICURR when the controller has detected an overcurrent condition; HIHEAT when the controller has detected an overheat condition; FAILSF when the controller switched on the failsafe security.</p><p> When an error condition occurred (LOVOLT, HICURR, HIHEAT, FAILSF), the controller status must be explicitly reset using the <tt>resetStatus</tt> function.</p>',ret:'a value among <tt>IDLE</tt>, <tt>BRAKE</tt>, <tt>FORWD</tt>, <tt>BACKWD</tt>, <tt>LOVOLT</tt>, <tt>HICURR</tt>, <tt>HIHEAT</tt> and <tt>FAILSF</tt>',ext:''};
doc['Motor']['get_overCurrentLimit']={syn:'Returns the current threshold (in mA) above which the controller automatically switches to error state.',lib:'YMotor get_overCurrentLimit',pro:'YMotor <span id=pn>target</span> get_overCurrentLimit',cmt:'<p>Returns the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit.</p>',ret:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state',ext:''};
doc['Motor']['get_starterTime']={syn:'Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'YMotor get_starterTime',pro:'YMotor <span id=pn>target</span> get_starterTime',cmt:'<p>Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',ret:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up',ext:''};
doc['Motor']['keepALive']={syn:'Rearms the controller failsafe timer.',lib:'YMotor keepALive',pro:'YMotor <span id=pn>target</span> keepALive',cmt:'<p>Rearms the controller failsafe timer. When the motor is running and the failsafe feature is active, this function should be called periodically to prove that the control process is running properly. Otherwise, the motor is automatically stopped after the specified timeout. Calling a motor <i>set</i> function implicitely rearms the failsafe timer.</p>'};
doc['Motor']['resetStatus']={syn:'Reset the controller state to IDLE.',lib:'YMotor resetStatus',pro:'YMotor <span id=pn>target</span> resetStatus',cmt:'<p>Reset the controller state to IDLE. This function must be invoked explicitely after any error condition is signaled.</p>'};
doc['Motor']['set_brakingForce']={syn:'Changes immediately the braking force applied to the motor (in percents).',lib:'YMotor set_brakingForce',pro:'YMotor <span id=pn>target</span> set_brakingForce <span id=pn>newval</span>',cmt:'<p>Changes immediately the braking force applied to the motor (in percents). The value 0 corresponds to no braking (free wheel). When the braking force is changed, the driving power is set to zero. The value is a percentage.</p>',par:{newval:'a floating point number corresponding to immediately the braking force applied to the motor (in percents)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_cutOffVoltage']={syn:'Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'YMotor set_cutOffVoltage',pro:'YMotor <span id=pn>target</span> set_cutOffVoltage <span id=pn>newval</span>',cmt:'<p>Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevent damage to a battery that can occur when drawing current from an \x22empty\x22 battery. Note that whatever the cutoff threshold, the controller switches to undervoltage error state if the power supply goes under 3V, even for a very brief time.</p>',par:{newval:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_drivingForce']={syn:'Changes immediately the power sent to the motor.',lib:'YMotor set_drivingForce',pro:'YMotor <span id=pn>target</span> set_drivingForce <span id=pn>newval</span>',cmt:'<p>Changes immediately the power sent to the motor. The value is a percentage between -100% to 100%. If you want go easy on your mechanics and avoid excessive current consumption, try to avoid brutal power changes. For example, immediate transition from forward full power to reverse full power is a very bad idea. Each time the driving power is modified, the braking power is set to zero.</p>',par:{newval:'a floating point number corresponding to immediately the power sent to the motor'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_failSafeTimeout']={syn:'Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'YMotor set_failSafeTimeout',pro:'YMotor <span id=pn>target</span> set_failSafeTimeout <span id=pn>newval</span>',cmt:'<p>Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',par:{newval:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_frequency']={syn:'Changes the PWM frequency used to control the motor.',lib:'YMotor set_frequency',pro:'YMotor <span id=pn>target</span> set_frequency <span id=pn>newval</span>',cmt:'<p>Changes the PWM frequency used to control the motor. Low frequency is usually more efficient and may help the motor to start, but an audible noise might be generated. A higher frequency reduces the noise, but more energy is converted into heat.</p>',par:{newval:'a floating point number corresponding to the PWM frequency used to control the motor'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_logicalName']={syn:'Changes the logical name of the motor.',lib:'YMotor set_logicalName',pro:'YMotor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the motor.</p>',par:{newval:'a string corresponding to the logical name of the motor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_overCurrentLimit']={syn:'Changes the current threshold (in mA) above which the controller automatically switches to error state.',lib:'YMotor set_overCurrentLimit',pro:'YMotor <span id=pn>target</span> set_overCurrentLimit <span id=pn>newval</span>',cmt:'<p>Changes the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit. Note that whatever the current limit is, the controller switches to OVERCURRENT status if the current goes above 32A, even for a very brief time.</p>',par:{newval:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Motor']['set_starterTime']={syn:'Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'YMotor set_starterTime',pro:'YMotor <span id=pn>target</span> set_starterTime <span id=pn>newval</span>',cmt:'<p>Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',par:{newval:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Motor)
//--- (generated code: SerialPort)
doc['SerialPort']={'':{syn:'SerialPort function interface',inc:'',cmt:'<p>The SerialPort function interface allows you to fully drive a Yoctopuce serial port, to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce serial ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}};
doc['SerialPort']['get_CTS']={syn:'Reads the level of the CTS line.',lib:'YSerialPort get_CTS',pro:'YSerialPort <span id=pn>target</span> get_CTS',cmt:'<p>Reads the level of the CTS line. The CTS line is usually driven by the RTS signal of the connected serial device.</p>',ret:'1 if the CTS line is high, 0 if the CTS line is low.',ext:''};
doc['SerialPort']['get_advertisedValue']={syn:'Returns the current value of the serial port (no more than 6 characters).',lib:'YSerialPort get_advertisedValue',pro:'YSerialPort <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the serial port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the serial port (no more than 6 characters).',ext:''};
doc['SerialPort']['get_currentJob']={syn:'Returns the name of the job file currently in use.',lib:'YSerialPort get_currentJob',pro:'YSerialPort <span id=pn>target</span> get_currentJob',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:''};
doc['SerialPort']['get_errCount']={syn:'Returns the total number of communication errors detected since last reset.',lib:'YSerialPort get_errCount',pro:'YSerialPort <span id=pn>target</span> get_errCount',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:''};
doc['SerialPort']['get_lastMsg']={syn:'Returns the latest message fully received (for Line, Frame and Modbus protocols).',lib:'YSerialPort get_lastMsg',pro:'YSerialPort <span id=pn>target</span> get_lastMsg',cmt:'<p>Returns the latest message fully received (for Line, Frame and Modbus protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line, Frame and Modbus protocols)',ext:''};
doc['SerialPort']['get_logicalName']={syn:'Returns the logical name of the serial port.',lib:'YSerialPort get_logicalName',pro:'YSerialPort <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the serial port.</p>',ret:'a string corresponding to the logical name of the serial port.',ext:''};
doc['SerialPort']['get_protocol']={syn:'Returns the type of protocol used over the serial line, as a string.',lib:'YSerialPort get_protocol',pro:'YSerialPort <span id=pn>target</span> get_protocol',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:''};
doc['SerialPort']['get_rxCount']={syn:'Returns the total number of bytes received since last reset.',lib:'YSerialPort get_rxCount',pro:'YSerialPort <span id=pn>target</span> get_rxCount',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:''};
doc['SerialPort']['get_rxMsgCount']={syn:'Returns the total number of messages received since last reset.',lib:'YSerialPort get_rxMsgCount',pro:'YSerialPort <span id=pn>target</span> get_rxMsgCount',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:''};
doc['SerialPort']['get_serialMode']={syn:'Returns the serial port communication parameters, as a string such as \x229600,8N1\x22.',lib:'YSerialPort get_serialMode',pro:'YSerialPort <span id=pn>target</span> get_serialMode',cmt:'<p>Returns the serial port communication parameters, as a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix is included if flow control is active: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',ret:'a string corresponding to the serial port communication parameters, as a string such as \x229600,8N1\x22',ext:''};
doc['SerialPort']['get_startupJob']={syn:'Returns the job file to use when the device is powered on.',lib:'YSerialPort get_startupJob',pro:'YSerialPort <span id=pn>target</span> get_startupJob',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:''};
doc['SerialPort']['get_txCount']={syn:'Returns the total number of bytes transmitted since last reset.',lib:'YSerialPort get_txCount',pro:'YSerialPort <span id=pn>target</span> get_txCount',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:''};
doc['SerialPort']['get_txMsgCount']={syn:'Returns the total number of messages send since last reset.',lib:'YSerialPort get_txMsgCount',pro:'YSerialPort <span id=pn>target</span> get_txMsgCount',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:''};
doc['SerialPort']['get_voltageLevel']={syn:'Returns the voltage level used on the serial line.',lib:'YSerialPort get_voltageLevel',pro:'YSerialPort <span id=pn>target</span> get_voltageLevel',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>OFF</tt>, <tt>TTL3V</tt>, <tt>TTL3VR</tt>, <tt>TTL5V</tt>, <tt>TTL5VR</tt>, <tt>RS232</tt> and <tt>RS485</tt> corresponding to the voltage level used on the serial line',ext:''};
doc['SerialPort']['modbusReadBits']={syn:'Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device.',lib:'YSerialPort modbusReadBits',pro:'YSerialPort <span id=pn>target</span> modbusReadBits <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>nBits</span>',cmt:'<p>Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device. This method uses the MODBUS function code 0x01 (Read Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/coil to read (zero-based)',nBits:'the number of bits/coils to read'},ret:'a vector of integers, each corresponding to one bit.',ext:''};
doc['SerialPort']['modbusReadInputBits']={syn:'Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device.',lib:'YSerialPort modbusReadInputBits',pro:'YSerialPort <span id=pn>target</span> modbusReadInputBits <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>nBits</span>',cmt:'<p>Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device. This method uses the MODBUS function code 0x02 (Read Discrete Inputs).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/input to read (zero-based)',nBits:'the number of bits/inputs to read'},ret:'a vector of integers, each corresponding to one bit.',ext:''};
doc['SerialPort']['modbusReadInputRegisters']={syn:'Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device.',lib:'YSerialPort modbusReadInputRegisters',pro:'YSerialPort <span id=pn>target</span> modbusReadInputRegisters <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>nWords</span>',cmt:'<p>Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device. This method uses the MODBUS function code 0x04 (Read Input Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first input register to read (zero-based)',nWords:'the number of input registers to read'},ret:'a vector of integers, each corresponding to one 16-bit input value.',ext:''};
doc['SerialPort']['modbusReadRegisters']={syn:'Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device.',lib:'YSerialPort modbusReadRegisters',pro:'YSerialPort <span id=pn>target</span> modbusReadRegisters <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>nWords</span>',cmt:'<p>Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device. This method uses the MODBUS function code 0x03 (Read Holding Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first holding register to read (zero-based)',nWords:'the number of holding registers to read'},ret:'a vector of integers, each corresponding to one 16-bit register value.',ext:''};
doc['SerialPort']['modbusWriteAndReadRegisters']={syn:'Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers.',lib:'YSerialPort modbusWriteAndReadRegisters',pro:'YSerialPort <span id=pn>target</span> modbusWriteAndReadRegisters <span id=pn>slaveNo</span> <span id=pn>pduWriteAddr</span> <span id=pn>values</span> <span id=pn>pduReadAddr</span> <span id=pn>nReadWords</span>',cmt:'<p>Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers. This method uses the MODBUS function code 0x17 (Read/Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduWriteAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set',pduReadAddr:'the relative address of the first internal register to read (zero-based)',nReadWords:'the number of 16 bit values to read'},ret:'a vector of integers, each corresponding to one 16-bit register value read.',ext:''};
doc['SerialPort']['modbusWriteBit']={syn:'Sets a single internal bit (or coil) on a MODBUS serial device.',lib:'YSerialPort modbusWriteBit',pro:'YSerialPort <span id=pn>target</span> modbusWriteBit <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>value</span>',cmt:'<p>Sets a single internal bit (or coil) on a MODBUS serial device. This method uses the MODBUS function code 0x05 (Write Single Coil).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the bit/coil to set (zero-based)',value:'the value to set (0 for OFF state, non-zero for ON state)'},ret:'the number of bits/coils affected on the device (1)',ext:''};
doc['SerialPort']['modbusWriteBits']={syn:'Sets several contiguous internal bits (or coils) on a MODBUS serial device.',lib:'YSerialPort modbusWriteBits',pro:'YSerialPort <span id=pn>target</span> modbusWriteBits <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>bits</span>',cmt:'<p>Sets several contiguous internal bits (or coils) on a MODBUS serial device. This method uses the MODBUS function code 0x0f (Write Multiple Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first bit/coil to set (zero-based)',bits:'the vector of bits to be set (one integer per bit)'},ret:'the number of bits/coils affected on the device',ext:''};
doc['SerialPort']['modbusWriteRegister']={syn:'Sets a single internal register (or holding register) on a MODBUS serial device.',lib:'YSerialPort modbusWriteRegister',pro:'YSerialPort <span id=pn>target</span> modbusWriteRegister <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>value</span>',cmt:'<p>Sets a single internal register (or holding register) on a MODBUS serial device. This method uses the MODBUS function code 0x06 (Write Single Register).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the register to set (zero-based)',value:'the 16 bit value to set'},ret:'the number of registers affected on the device (1)',ext:''};
doc['SerialPort']['modbusWriteRegisters']={syn:'Sets several contiguous internal registers (or holding registers) on a MODBUS serial device.',lib:'YSerialPort modbusWriteRegisters',pro:'YSerialPort <span id=pn>target</span> modbusWriteRegisters <span id=pn>slaveNo</span> <span id=pn>pduAddr</span> <span id=pn>values</span>',cmt:'<p>Sets several contiguous internal registers (or holding registers) on a MODBUS serial device. This method uses the MODBUS function code 0x10 (Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set'},ret:'the number of registers affected on the device',ext:''};
doc['SerialPort']['queryLine']={syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'YSerialPort queryLine',pro:'YSerialPort <span id=pn>target</span> queryLine <span id=pn>query</span> <span id=pn>maxWait</span>',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:''};
doc['SerialPort']['queryMODBUS']={syn:'Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any.',lib:'YSerialPort queryMODBUS',pro:'YSerialPort <span id=pn>target</span> queryMODBUS <span id=pn>slaveNo</span> <span id=pn>pduBytes</span>',cmt:'<p>Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any. The message is the PDU, provided as a vector of bytes.</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduBytes:'the message to send (PDU), as a vector of bytes. The first byte of the PDU is the MODBUS function code.'},ret:'the received reply, as a vector of bytes.',ext:''};
doc['SerialPort']['readArray']={syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'YSerialPort readArray',pro:'YSerialPort <span id=pn>target</span> readArray <span id=pn>nChars</span>',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:''};
doc['SerialPort']['readBin']={syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'YSerialPort readBin',pro:'YSerialPort <span id=pn>target</span> readBin <span id=pn>nChars</span>',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:''};
doc['SerialPort']['readByte']={syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'YSerialPort readByte',pro:'YSerialPort <span id=pn>target</span> readByte',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:''};
doc['SerialPort']['readHex']={syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'YSerialPort readHex',pro:'YSerialPort <span id=pn>target</span> readHex <span id=pn>nBytes</span>',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:''};
doc['SerialPort']['readLine']={syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'YSerialPort readLine',pro:'YSerialPort <span id=pn>target</span> readLine',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or MODBUS protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:''};
doc['SerialPort']['readMessages']={syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'YSerialPort readMessages',pro:'YSerialPort <span id=pn>target</span> readMessages <span id=pn>pattern</span> <span id=pn>maxWait</span>',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:''};
doc['SerialPort']['readStr']={syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'YSerialPort readStr',pro:'YSerialPort <span id=pn>target</span> readStr <span id=pn>nChars</span>',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:''};
doc['SerialPort']['read_avail']={syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the YSerialPort object.',lib:'YSerialPort read_avail',pro:'YSerialPort <span id=pn>target</span> read_avail',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the YSerialPort object.</p>',ret:'the number of bytes available to read'};
doc['SerialPort']['read_seek']={syn:'Changes the current internal stream position to the specified value.',lib:'YSerialPort read_seek',pro:'YSerialPort <span id=pn>target</span> read_seek <span id=pn>absPos</span>',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the YSerialPort object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'};
doc['SerialPort']['read_tell']={syn:'Returns the current absolute stream position pointer of the YSerialPort object.',lib:'YSerialPort read_tell',pro:'YSerialPort <span id=pn>target</span> read_tell',cmt:'<p>Returns the current absolute stream position pointer of the YSerialPort object.</p>',ret:'the absolute position index for next read operations.'};
doc['SerialPort']['reset']={syn:'Clears the serial port buffer and resets counters to zero.',lib:'YSerialPort reset',pro:'YSerialPort <span id=pn>target</span> reset',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['selectJob']={syn:'Load and start processing the specified job file.',lib:'YSerialPort selectJob',pro:'YSerialPort <span id=pn>target</span> selectJob <span id=pn>jobfile</span>',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_RTS']={syn:'Manually sets the state of the RTS line.',lib:'YSerialPort set_RTS',pro:'YSerialPort <span id=pn>target</span> set_RTS <span id=pn>val</span>',cmt:'<p>Manually sets the state of the RTS line. This function has no effect when hardware handshake is enabled, as the RTS line is driven automatically.</p>',par:{val:'1 to turn RTS on, 0 to turn RTS off'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_currentJob']={syn:'Changes the job to use when the device is powered on.',lib:'YSerialPort set_currentJob',pro:'YSerialPort <span id=pn>target</span> set_currentJob <span id=pn>newval</span>',cmt:'<p>Changes the job to use when the device is powered on.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_logicalName']={syn:'Changes the logical name of the serial port.',lib:'YSerialPort set_logicalName',pro:'YSerialPort <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the serial port.</p>',par:{newval:'a string corresponding to the logical name of the serial port.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_protocol']={syn:'Changes the type of protocol used over the serial line.',lib:'YSerialPort set_protocol',pro:'YSerialPort <span id=pn>target</span> set_protocol <span id=pn>newval</span>',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_serialMode']={syn:'Changes the serial port communication parameters, with a string such as \x229600,8N1\x22.',lib:'YSerialPort set_serialMode',pro:'YSerialPort <span id=pn>target</span> set_serialMode <span id=pn>newval</span>',cmt:'<p>Changes the serial port communication parameters, with a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix can be added to enable flow control: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',par:{newval:'a string corresponding to the serial port communication parameters, with a string such as \x229600,8N1\x22'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_startupJob']={syn:'Changes the job to use when the device is powered on.',lib:'YSerialPort set_startupJob',pro:'YSerialPort <span id=pn>target</span> set_startupJob <span id=pn>newval</span>',cmt:'<p>Changes the job to use when the device is powered on.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['set_voltageLevel']={syn:'Changes the voltage type used on the serial line.',lib:'YSerialPort set_voltageLevel',pro:'YSerialPort <span id=pn>target</span> set_voltageLevel <span id=pn>newval</span>',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. \x09 Trying to set an invalid value will have no effect.</p>',par:{newval:'a value among <tt>OFF</tt>, <tt>TTL3V</tt>, <tt>TTL3VR</tt>, <tt>TTL5V</tt>, <tt>TTL5VR</tt>, <tt>RS232</tt> and <tt>RS485</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['uploadJob']={syn:'Saves the job definition string (JSON data) into a job file.',lib:'YSerialPort uploadJob',pro:'YSerialPort <span id=pn>target</span> uploadJob <span id=pn>jobfile</span> <span id=pn>jsonDef</span>',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeArray']={syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'YSerialPort writeArray',pro:'YSerialPort <span id=pn>target</span> writeArray <span id=pn>byteList</span>',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeBin']={syn:'Sends a binary buffer to the serial port, as is.',lib:'YSerialPort writeBin',pro:'YSerialPort <span id=pn>target</span> writeBin <span id=pn>buff</span>',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeByte']={syn:'Sends a single byte to the serial port.',lib:'YSerialPort writeByte',pro:'YSerialPort <span id=pn>target</span> writeByte <span id=pn>code</span>',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeHex']={syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'YSerialPort writeHex',pro:'YSerialPort <span id=pn>target</span> writeHex <span id=pn>hexString</span>',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeLine']={syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'YSerialPort writeLine',pro:'YSerialPort <span id=pn>target</span> writeLine <span id=pn>text</span>',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeMODBUS']={syn:'Sends a MODBUS message (provided as a hexadecimal string) to the serial port.',lib:'YSerialPort writeMODBUS',pro:'YSerialPort <span id=pn>target</span> writeMODBUS <span id=pn>hexString</span>',cmt:'<p>Sends a MODBUS message (provided as a hexadecimal string) to the serial port. The message must start with the slave address. The MODBUS CRC/LRC is automatically added by the function. This function does not wait for a reply.</p>',par:{hexString:'a hexadecimal message string, including device address but no CRC/LRC'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SerialPort']['writeStr']={syn:'Sends an ASCII string to the serial port, as is.',lib:'YSerialPort writeStr',pro:'YSerialPort <span id=pn>target</span> writeStr <span id=pn>text</span>',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: SerialPort)
//--- (generated code: PwmInput)
doc['PwmInput']={'':{syn:'PwmInput function interface',inc:'',cmt:'<p>The Yoctopuce class YPwmInput allows you to read and configure Yoctopuce PWM sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to configure the signal parameter used to transmit information: the duty cacle, the frequency or the pulse width.</p>'}};
doc['PwmInput']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YPwmInput calibrateFromPoints',pro:'YPwmInput <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['get_advertisedValue']={syn:'Returns the current value of the PWM input (no more than 6 characters).',lib:'YPwmInput get_advertisedValue',pro:'YPwmInput <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the PWM input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM input (no more than 6 characters).',ext:''};
doc['PwmInput']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.',lib:'YPwmInput get_currentRawValue',pro:'YPwmInput <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number',ext:''};
doc['PwmInput']['get_currentValue']={syn:'Returns the current value of the PwmInput feature as a floating point number.',lib:'YPwmInput get_currentValue',pro:'YPwmInput <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the PwmInput feature as a floating point number. Depending on the pwmReportMode setting, this can be the frequency, in Hz, the duty cycle in % or the pulse length in ms.</p>',ret:'a floating point number corresponding to the current value of the PwmInput feature as a floating point number',ext:''};
doc['PwmInput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'YPwmInput get_dutyCycle',pro:'YPwmInput <span id=pn>target</span> get_dutyCycle',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:''};
doc['PwmInput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'YPwmInput get_frequency',pro:'YPwmInput <span id=pn>target</span> get_frequency',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:''};
doc['PwmInput']['get_highestValue']={syn:'Returns the maximal value observed for the PWM since the device was started.',lib:'YPwmInput get_highestValue',pro:'YPwmInput <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the PWM since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the PWM since the device was started',ext:''};
doc['PwmInput']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YPwmInput get_logFrequency',pro:'YPwmInput <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['PwmInput']['get_logicalName']={syn:'Returns the logical name of the PWM input.',lib:'YPwmInput get_logicalName',pro:'YPwmInput <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the PWM input.</p>',ret:'a string corresponding to the logical name of the PWM input.',ext:''};
doc['PwmInput']['get_lowestValue']={syn:'Returns the minimal value observed for the PWM since the device was started.',lib:'YPwmInput get_lowestValue',pro:'YPwmInput <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the PWM since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the PWM since the device was started',ext:''};
doc['PwmInput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'YPwmInput get_period',pro:'YPwmInput <span id=pn>target</span> get_period',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:''};
doc['PwmInput']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'YPwmInput get_pulseCounter',pro:'YPwmInput <span id=pn>target</span> get_pulseCounter',cmt:'<p>Returns the pulse counter value. Actually that counter is incremented twice per period. That counter is limited to 1 billion</p>',ret:'an integer corresponding to the pulse counter value',ext:''};
doc['PwmInput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'YPwmInput get_pulseDuration',pro:'YPwmInput <span id=pn>target</span> get_pulseDuration',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:''};
doc['PwmInput']['get_pwmReportMode']={syn:'Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks.',lib:'YPwmInput get_pwmReportMode',pro:'YPwmInput <span id=pn>target</span> get_pwmReportMode',cmt:'<p>Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks. Attention</p>',ret:'a value among <tt>PWM_DUTYCYCLE</tt>, <tt>PWM_FREQUENCY</tt>, <tt>PWM_PULSEDURATION</tt> and <tt>PWM_EDGECOUNT</tt> corresponding to the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks',ext:''};
doc['PwmInput']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YPwmInput get_recordedData',pro:'YPwmInput <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['PwmInput']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YPwmInput get_reportFrequency',pro:'YPwmInput <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['PwmInput']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YPwmInput get_resolution',pro:'YPwmInput <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['PwmInput']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YPwmInput get_sensorState',pro:'YPwmInput <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['PwmInput']['get_unit']={syn:'Returns the measuring unit for the values returned by get_currentValue and callbacks.',lib:'YPwmInput get_unit',pro:'YPwmInput <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the values returned by get_currentValue and callbacks. This unit changes according to the pwmReportMode settings.</p>',ret:'a string corresponding to the measuring unit for the values returned by get_currentValue and callbacks',ext:''};
doc['PwmInput']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YPwmInput isSensorReady',pro:'YPwmInput <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['PwmInput']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YPwmInput loadCalibrationPoints',pro:'YPwmInput <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'YPwmInput resetCounter',pro:'YPwmInput <span id=pn>target</span> resetCounter',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YPwmInput set_highestValue',pro:'YPwmInput <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YPwmInput set_logFrequency',pro:'YPwmInput <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_logicalName']={syn:'Changes the logical name of the PWM input.',lib:'YPwmInput set_logicalName',pro:'YPwmInput <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the PWM input.</p>',par:{newval:'a string corresponding to the logical name of the PWM input.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YPwmInput set_lowestValue',pro:'YPwmInput <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_pwmReportMode']={syn:'Modifies the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks.',lib:'YPwmInput set_pwmReportMode',pro:'YPwmInput <span id=pn>target</span> set_pwmReportMode <span id=pn>newval</span>',cmt:'<p>Modifies the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter().</p>',par:{newval:'a value among <tt>PWM_DUTYCYCLE</tt>, <tt>PWM_FREQUENCY</tt>, <tt>PWM_PULSEDURATION</tt> and <tt>PWM_EDGECOUNT</tt>'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YPwmInput set_reportFrequency',pro:'YPwmInput <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YPwmInput set_resolution',pro:'YPwmInput <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PwmInput']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YPwmInput startDataLogger',pro:'YPwmInput <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['PwmInput']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YPwmInput stopDataLogger',pro:'YPwmInput <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: PwmInput)
//--- (generated code: SegmentedDisplay)
doc['SegmentedDisplay']={'':{syn:'SegmentedDisplay function interface',inc:'',cmt:'<p>The SegmentedDisplay class allows you to drive segmented displays.</p>'}};
doc['SegmentedDisplay']['get_advertisedValue']={syn:'Returns the current value of the segmented displays (no more than 6 characters).',lib:'YSegmentedDisplay get_advertisedValue',pro:'YSegmentedDisplay <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the segmented displays (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the segmented displays (no more than 6 characters).',ext:''};
doc['SegmentedDisplay']['get_displayedText']={syn:'Returns the text currently displayed on the screen.',lib:'YSegmentedDisplay get_displayedText',pro:'YSegmentedDisplay <span id=pn>target</span> get_displayedText',cmt:'<p>Returns the text currently displayed on the screen.</p>',ret:'a string corresponding to the text currently displayed on the screen',ext:''};
doc['SegmentedDisplay']['get_logicalName']={syn:'Returns the logical name of the segmented displays.',lib:'YSegmentedDisplay get_logicalName',pro:'YSegmentedDisplay <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the segmented displays.</p>',ret:'a string corresponding to the logical name of the segmented displays.',ext:''};
doc['SegmentedDisplay']['set_displayedText']={syn:'Changes the text currently displayed on the screen.',lib:'YSegmentedDisplay set_displayedText',pro:'YSegmentedDisplay <span id=pn>target</span> set_displayedText <span id=pn>newval</span>',cmt:'<p>Changes the text currently displayed on the screen.</p>',par:{newval:'a string corresponding to the text currently displayed on the screen'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['SegmentedDisplay']['set_logicalName']={syn:'Changes the logical name of the segmented displays.',lib:'YSegmentedDisplay set_logicalName',pro:'YSegmentedDisplay <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the segmented displays.</p>',par:{newval:'a string corresponding to the logical name of the segmented displays.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: SegmentedDisplay)
//--- (generated code: Buzzer)
doc['Buzzer']={'':{syn:'Buzzer function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to choose the frequency and volume at which the buzzer must sound. You can also pre-program a play sequence.</p>'}};
doc['Buzzer']['addFreqMoveToPlaySeq']={syn:'Adds a new frequency transition to the playing sequence.',lib:'YBuzzer addFreqMoveToPlaySeq',pro:'YBuzzer <span id=pn>target</span> addFreqMoveToPlaySeq <span id=pn>freq</span> <span id=pn>msDelay</span>',cmt:'<p>Adds a new frequency transition to the playing sequence.</p>',par:{freq:'desired frequency when the transition is completed, in Hz',msDelay:'duration of the frequency transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addPulseToPlaySeq']={syn:'Adds a pulse to the playing sequence.',lib:'YBuzzer addPulseToPlaySeq',pro:'YBuzzer <span id=pn>target</span> addPulseToPlaySeq <span id=pn>freq</span> <span id=pn>msDuration</span>',cmt:'<p>Adds a pulse to the playing sequence.</p>',par:{freq:'pulse frequency, in Hz',msDuration:'pulse duration, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addVolMoveToPlaySeq']={syn:'Adds a new volume transition to the playing sequence.',lib:'YBuzzer addVolMoveToPlaySeq',pro:'YBuzzer <span id=pn>target</span> addVolMoveToPlaySeq <span id=pn>volume</span> <span id=pn>msDuration</span>',cmt:'<p>Adds a new volume transition to the playing sequence. Frequency stays untouched: if frequency is at zero, the transition has no effect.</p>',par:{volume:'desired volume when the transition is completed, as a percentage.',msDuration:'duration of the volume transition, in milliseconds.'},ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['freqMove']={syn:'Makes the buzzer frequency change over a period of time.',lib:'YBuzzer freqMove',pro:'YBuzzer <span id=pn>target</span> freqMove <span id=pn>frequency</span> <span id=pn>duration</span>',cmt:'<p>Makes the buzzer frequency change over a period of time.</p>',par:{frequency:'frequency to reach, in hertz. A frequency under 25Hz stops the buzzer.',duration:'pulse duration in millseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['get_advertisedValue']={syn:'Returns the current value of the buzzer (no more than 6 characters).',lib:'YBuzzer get_advertisedValue',pro:'YBuzzer <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the buzzer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the buzzer (no more than 6 characters).',ext:''};
doc['Buzzer']['get_frequency']={syn:'Returns the frequency of the signal sent to the buzzer/speaker.',lib:'YBuzzer get_frequency',pro:'YBuzzer <span id=pn>target</span> get_frequency',cmt:'<p>Returns the frequency of the signal sent to the buzzer/speaker.</p>',ret:'a floating point number corresponding to the frequency of the signal sent to the buzzer/speaker',ext:''};
doc['Buzzer']['get_logicalName']={syn:'Returns the logical name of the buzzer.',lib:'YBuzzer get_logicalName',pro:'YBuzzer <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the buzzer.</p>',ret:'a string corresponding to the logical name of the buzzer.',ext:''};
doc['Buzzer']['get_playSeqSignature']={syn:'Returns the playing sequence signature.',lib:'YBuzzer get_playSeqSignature',pro:'YBuzzer <span id=pn>target</span> get_playSeqSignature',cmt:'<p>Returns the playing sequence signature. As playing sequences cannot be read from the device, this can be used to detect if a specific playing sequence is already programmed.</p>',ret:'an integer corresponding to the playing sequence signature',ext:''};
doc['Buzzer']['get_volume']={syn:'Returns the volume of the signal sent to the buzzer/speaker.',lib:'YBuzzer get_volume',pro:'YBuzzer <span id=pn>target</span> get_volume',cmt:'<p>Returns the volume of the signal sent to the buzzer/speaker.</p>',ret:'an integer corresponding to the volume of the signal sent to the buzzer/speaker',ext:''};
doc['Buzzer']['pulse']={syn:'Activates the buzzer for a short duration.',lib:'YBuzzer pulse',pro:'YBuzzer <span id=pn>target</span> pulse <span id=pn>frequency</span> <span id=pn>duration</span>',cmt:'<p>Activates the buzzer for a short duration.</p>',par:{frequency:'pulse frequency, in hertz',duration:'pulse duration in millseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['resetPlaySeq']={syn:'Resets the preprogrammed playing sequence and sets the frequency to zero.',lib:'YBuzzer resetPlaySeq',pro:'YBuzzer <span id=pn>target</span> resetPlaySeq',cmt:'<p>Resets the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_frequency']={syn:'Changes the frequency of the signal sent to the buzzer.',lib:'YBuzzer set_frequency',pro:'YBuzzer <span id=pn>target</span> set_frequency <span id=pn>newval</span>',cmt:'<p>Changes the frequency of the signal sent to the buzzer. A zero value stops the buzzer.</p>',par:{newval:'a floating point number corresponding to the frequency of the signal sent to the buzzer'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['set_logicalName']={syn:'Changes the logical name of the buzzer.',lib:'YBuzzer set_logicalName',pro:'YBuzzer <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the buzzer.</p>',par:{newval:'a string corresponding to the logical name of the buzzer.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['set_volume']={syn:'Changes the volume of the signal sent to the buzzer/speaker.',lib:'YBuzzer set_volume',pro:'YBuzzer <span id=pn>target</span> set_volume <span id=pn>newval</span>',cmt:'<p>Changes the volume of the signal sent to the buzzer/speaker.</p>',par:{newval:'an integer corresponding to the volume of the signal sent to the buzzer/speaker'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Buzzer']['startPlaySeq']={syn:'Starts the preprogrammed playing sequence.',lib:'YBuzzer startPlaySeq',pro:'YBuzzer <span id=pn>target</span> startPlaySeq',cmt:'<p>Starts the preprogrammed playing sequence. The sequence runs in loop until it is stopped by stopPlaySeq or an explicit change.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['stopPlaySeq']={syn:'Stops the preprogrammed playing sequence and sets the frequency to zero.',lib:'YBuzzer stopPlaySeq',pro:'YBuzzer <span id=pn>target</span> stopPlaySeq',cmt:'<p>Stops the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>OK</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['volumeMove']={syn:'Makes the buzzer volume change over a period of time, frequency stays untouched.',lib:'YBuzzer volumeMove',pro:'YBuzzer <span id=pn>target</span> volumeMove <span id=pn>volume</span> <span id=pn>duration</span>',cmt:'<p>Makes the buzzer volume change over a period of time, frequency stays untouched.</p>',par:{volume:'volume to reach in %',duration:'change duration in millseconds'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Buzzer)
//--- (generated code: Gps)
doc['Gps']={'':{syn:'GPS function interface',inc:'',cmt:'<p>The Gps function allows you to extract positionning data from the GPS device. This class can provides complete positionning information: However, if you whish to define callbacks on position changes, you should use the YLatitude et YLongitude classes.</p>'}};
doc['Gps']['get_advertisedValue']={syn:'Returns the current value of the GPS (no more than 6 characters).',lib:'YGps get_advertisedValue',pro:'YGps <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the GPS (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the GPS (no more than 6 characters).',ext:''};
doc['Gps']['get_altitude']={syn:'Returns the current altitude.',lib:'YGps get_altitude',pro:'YGps <span id=pn>target</span> get_altitude',cmt:'<p>Returns the current altitude. Beware: GPS technology is very inaccurate regarding altitude.</p>',ret:'a floating point number corresponding to the current altitude',ext:''};
doc['Gps']['get_coordSystem']={syn:'Returns the representation system used for positioning data.',lib:'YGps get_coordSystem',pro:'YGps <span id=pn>target</span> get_coordSystem',cmt:'<p>Returns the representation system used for positioning data.</p>',ret:'a value among <tt>GPS_DMS</tt>, <tt>GPS_DM</tt> and <tt>GPS_D</tt> corresponding to the representation system used for positioning data',ext:''};
doc['Gps']['get_dilution']={syn:'Returns the current horizontal dilution of precision, the smaller that number is, the better .',lib:'YGps get_dilution',pro:'YGps <span id=pn>target</span> get_dilution',cmt:'<p>Returns the current horizontal dilution of precision, the smaller that number is, the better .</p>',ret:'a floating point number corresponding to the current horizontal dilution of precision, the smaller that number is, the better',ext:''};
doc['Gps']['get_direction']={syn:'Returns the current move bearing in degrees, zero is the true (geographic) north.',lib:'YGps get_direction',pro:'YGps <span id=pn>target</span> get_direction',cmt:'<p>Returns the current move bearing in degrees, zero is the true (geographic) north.</p>',ret:'a floating point number corresponding to the current move bearing in degrees, zero is the true (geographic) north',ext:''};
doc['Gps']['get_groundSpeed']={syn:'Returns the current ground speed in Km/h.',lib:'YGps get_groundSpeed',pro:'YGps <span id=pn>target</span> get_groundSpeed',cmt:'<p>Returns the current ground speed in Km/h.</p>',ret:'a floating point number corresponding to the current ground speed in Km/h',ext:''};
doc['Gps']['get_latitude']={syn:'Returns the current latitude.',lib:'YGps get_latitude',pro:'YGps <span id=pn>target</span> get_latitude',cmt:'<p>Returns the current latitude.</p>',ret:'a string corresponding to the current latitude',ext:''};
doc['Gps']['get_logicalName']={syn:'Returns the logical name of the GPS.',lib:'YGps get_logicalName',pro:'YGps <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the GPS.</p>',ret:'a string corresponding to the logical name of the GPS.',ext:''};
doc['Gps']['get_longitude']={syn:'Returns the current longitude.',lib:'YGps get_longitude',pro:'YGps <span id=pn>target</span> get_longitude',cmt:'<p>Returns the current longitude.</p>',ret:'a string corresponding to the current longitude',ext:''};
doc['Gps']['get_satCount']={syn:'Returns the count of visible satellites.',lib:'YGps get_satCount',pro:'YGps <span id=pn>target</span> get_satCount',cmt:'<p>Returns the count of visible satellites.</p>',ret:'an integer corresponding to the count of visible satellites',ext:''};
doc['Gps']['get_unixTime']={syn:'Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).',lib:'YGps get_unixTime',pro:'YGps <span id=pn>target</span> get_unixTime',cmt:'<p>Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of seconds elapsed since Jan 1st, 1970)',ext:''};
doc['Gps']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'YGps get_utcOffset',pro:'YGps <span id=pn>target</span> get_utcOffset',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:''};
doc['Gps']['set_coordSystem']={syn:'Changes the representation system used for positioning data.',lib:'YGps set_coordSystem',pro:'YGps <span id=pn>target</span> set_coordSystem <span id=pn>newval</span>',cmt:'<p>Changes the representation system used for positioning data.</p>',par:{newval:'a value among <tt>GPS_DMS</tt>, <tt>GPS_DM</tt> and <tt>GPS_D</tt> corresponding to the representation system used for positioning data'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gps']['set_logicalName']={syn:'Changes the logical name of the GPS.',lib:'YGps set_logicalName',pro:'YGps <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the GPS.</p>',par:{newval:'a string corresponding to the logical name of the GPS.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Gps']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'YGps set_utcOffset',pro:'YGps <span id=pn>target</span> set_utcOffset <span id=pn>newval</span>',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. If current UTC time is known, the current time is automatically be updated according to the selected time zone.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Gps)
//--- (generated code: Latitude)
doc['Latitude']={'':{syn:'Latitude function interface',inc:'',cmt:'<p>The Yoctopuce class YLatitude allows you to read the latitude from Yoctopuce geolocalization sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['Latitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YLatitude calibrateFromPoints',pro:'YLatitude <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['get_advertisedValue']={syn:'Returns the current value of the latitude sensor (no more than 6 characters).',lib:'YLatitude get_advertisedValue',pro:'YLatitude <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the latitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the latitude sensor (no more than 6 characters).',ext:''};
doc['Latitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'YLatitude get_currentRawValue',pro:'YLatitude <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:''};
doc['Latitude']['get_currentValue']={syn:'Returns the current value of the latitude, in deg/1000, as a floating point number.',lib:'YLatitude get_currentValue',pro:'YLatitude <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the latitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the latitude, in deg/1000, as a floating point number',ext:''};
doc['Latitude']['get_highestValue']={syn:'Returns the maximal value observed for the latitude since the device was started.',lib:'YLatitude get_highestValue',pro:'YLatitude <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the latitude since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the latitude since the device was started',ext:''};
doc['Latitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YLatitude get_logFrequency',pro:'YLatitude <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Latitude']['get_logicalName']={syn:'Returns the logical name of the latitude sensor.',lib:'YLatitude get_logicalName',pro:'YLatitude <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the latitude sensor.</p>',ret:'a string corresponding to the logical name of the latitude sensor.',ext:''};
doc['Latitude']['get_lowestValue']={syn:'Returns the minimal value observed for the latitude since the device was started.',lib:'YLatitude get_lowestValue',pro:'YLatitude <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the latitude since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the latitude since the device was started',ext:''};
doc['Latitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YLatitude get_recordedData',pro:'YLatitude <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Latitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YLatitude get_reportFrequency',pro:'YLatitude <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Latitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YLatitude get_resolution',pro:'YLatitude <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Latitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YLatitude get_sensorState',pro:'YLatitude <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Latitude']['get_unit']={syn:'Returns the measuring unit for the latitude.',lib:'YLatitude get_unit',pro:'YLatitude <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the latitude.</p>',ret:'a string corresponding to the measuring unit for the latitude',ext:''};
doc['Latitude']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YLatitude isSensorReady',pro:'YLatitude <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Latitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YLatitude loadCalibrationPoints',pro:'YLatitude <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YLatitude set_highestValue',pro:'YLatitude <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YLatitude set_logFrequency',pro:'YLatitude <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_logicalName']={syn:'Changes the logical name of the latitude sensor.',lib:'YLatitude set_logicalName',pro:'YLatitude <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the latitude sensor.</p>',par:{newval:'a string corresponding to the logical name of the latitude sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YLatitude set_lowestValue',pro:'YLatitude <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YLatitude set_reportFrequency',pro:'YLatitude <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YLatitude set_resolution',pro:'YLatitude <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Latitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YLatitude startDataLogger',pro:'YLatitude <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Latitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YLatitude stopDataLogger',pro:'YLatitude <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Latitude)
//--- (generated code: Longitude)
doc['Longitude']={'':{syn:'Longitude function interface',inc:'',cmt:'<p>The Yoctopuce class YLongitude allows you to read the longitude from Yoctopuce geolocalization sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['Longitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YLongitude calibrateFromPoints',pro:'YLongitude <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['get_advertisedValue']={syn:'Returns the current value of the longitude sensor (no more than 6 characters).',lib:'YLongitude get_advertisedValue',pro:'YLongitude <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the longitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the longitude sensor (no more than 6 characters).',ext:''};
doc['Longitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'YLongitude get_currentRawValue',pro:'YLongitude <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:''};
doc['Longitude']['get_currentValue']={syn:'Returns the current value of the longitude, in deg/1000, as a floating point number.',lib:'YLongitude get_currentValue',pro:'YLongitude <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the longitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the longitude, in deg/1000, as a floating point number',ext:''};
doc['Longitude']['get_highestValue']={syn:'Returns the maximal value observed for the longitude since the device was started.',lib:'YLongitude get_highestValue',pro:'YLongitude <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the longitude since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the longitude since the device was started',ext:''};
doc['Longitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YLongitude get_logFrequency',pro:'YLongitude <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Longitude']['get_logicalName']={syn:'Returns the logical name of the longitude sensor.',lib:'YLongitude get_logicalName',pro:'YLongitude <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the longitude sensor.</p>',ret:'a string corresponding to the logical name of the longitude sensor.',ext:''};
doc['Longitude']['get_lowestValue']={syn:'Returns the minimal value observed for the longitude since the device was started.',lib:'YLongitude get_lowestValue',pro:'YLongitude <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the longitude since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the longitude since the device was started',ext:''};
doc['Longitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YLongitude get_recordedData',pro:'YLongitude <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Longitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YLongitude get_reportFrequency',pro:'YLongitude <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Longitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YLongitude get_resolution',pro:'YLongitude <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Longitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YLongitude get_sensorState',pro:'YLongitude <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Longitude']['get_unit']={syn:'Returns the measuring unit for the longitude.',lib:'YLongitude get_unit',pro:'YLongitude <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the longitude.</p>',ret:'a string corresponding to the measuring unit for the longitude',ext:''};
doc['Longitude']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YLongitude isSensorReady',pro:'YLongitude <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Longitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YLongitude loadCalibrationPoints',pro:'YLongitude <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YLongitude set_highestValue',pro:'YLongitude <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YLongitude set_logFrequency',pro:'YLongitude <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_logicalName']={syn:'Changes the logical name of the longitude sensor.',lib:'YLongitude set_logicalName',pro:'YLongitude <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the longitude sensor.</p>',par:{newval:'a string corresponding to the logical name of the longitude sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YLongitude set_lowestValue',pro:'YLongitude <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YLongitude set_reportFrequency',pro:'YLongitude <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YLongitude set_resolution',pro:'YLongitude <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Longitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YLongitude startDataLogger',pro:'YLongitude <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Longitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YLongitude stopDataLogger',pro:'YLongitude <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Longitude)
//--- (generated code: GroundSpeed)
doc['GroundSpeed']={'':{syn:'GroundSpeed function interface',inc:'',cmt:'<p>The Yoctopuce class YGroundSpeed allows you to read the ground speed from Yoctopuce geolocalization sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['GroundSpeed']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YGroundSpeed calibrateFromPoints',pro:'YGroundSpeed <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['get_advertisedValue']={syn:'Returns the current value of the ground speed sensor (no more than 6 characters).',lib:'YGroundSpeed get_advertisedValue',pro:'YGroundSpeed <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the ground speed sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the ground speed sensor (no more than 6 characters).',ext:''};
doc['GroundSpeed']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.',lib:'YGroundSpeed get_currentRawValue',pro:'YGroundSpeed <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number',ext:''};
doc['GroundSpeed']['get_currentValue']={syn:'Returns the current value of the ground speed, in km/h, as a floating point number.',lib:'YGroundSpeed get_currentValue',pro:'YGroundSpeed <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the ground speed, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ground speed, in km/h, as a floating point number',ext:''};
doc['GroundSpeed']['get_highestValue']={syn:'Returns the maximal value observed for the ground speed since the device was started.',lib:'YGroundSpeed get_highestValue',pro:'YGroundSpeed <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the ground speed since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the ground speed since the device was started',ext:''};
doc['GroundSpeed']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YGroundSpeed get_logFrequency',pro:'YGroundSpeed <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['GroundSpeed']['get_logicalName']={syn:'Returns the logical name of the ground speed sensor.',lib:'YGroundSpeed get_logicalName',pro:'YGroundSpeed <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the ground speed sensor.</p>',ret:'a string corresponding to the logical name of the ground speed sensor.',ext:''};
doc['GroundSpeed']['get_lowestValue']={syn:'Returns the minimal value observed for the ground speed since the device was started.',lib:'YGroundSpeed get_lowestValue',pro:'YGroundSpeed <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the ground speed since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the ground speed since the device was started',ext:''};
doc['GroundSpeed']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YGroundSpeed get_recordedData',pro:'YGroundSpeed <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GroundSpeed']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YGroundSpeed get_reportFrequency',pro:'YGroundSpeed <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['GroundSpeed']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YGroundSpeed get_resolution',pro:'YGroundSpeed <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['GroundSpeed']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YGroundSpeed get_sensorState',pro:'YGroundSpeed <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['GroundSpeed']['get_unit']={syn:'Returns the measuring unit for the ground speed.',lib:'YGroundSpeed get_unit',pro:'YGroundSpeed <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the ground speed.</p>',ret:'a string corresponding to the measuring unit for the ground speed',ext:''};
doc['GroundSpeed']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YGroundSpeed isSensorReady',pro:'YGroundSpeed <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['GroundSpeed']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YGroundSpeed loadCalibrationPoints',pro:'YGroundSpeed <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YGroundSpeed set_highestValue',pro:'YGroundSpeed <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YGroundSpeed set_logFrequency',pro:'YGroundSpeed <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_logicalName']={syn:'Changes the logical name of the ground speed sensor.',lib:'YGroundSpeed set_logicalName',pro:'YGroundSpeed <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the ground speed sensor.</p>',par:{newval:'a string corresponding to the logical name of the ground speed sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YGroundSpeed set_lowestValue',pro:'YGroundSpeed <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YGroundSpeed set_reportFrequency',pro:'YGroundSpeed <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YGroundSpeed set_resolution',pro:'YGroundSpeed <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['GroundSpeed']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YGroundSpeed startDataLogger',pro:'YGroundSpeed <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['GroundSpeed']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YGroundSpeed stopDataLogger',pro:'YGroundSpeed <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: GroundSpeed)
//--- (generated code: PowerOutput)
doc['PowerOutput']={'':{syn:'External power supply control interface',inc:'',cmt:'<p>Yoctopuce application programming interface allows you to control the power ouput featured on some devices such as the Yocto-Serial.</p>'}};
doc['PowerOutput']['get_advertisedValue']={syn:'Returns the current value of the power ouput control (no more than 6 characters).',lib:'YPowerOutput get_advertisedValue',pro:'YPowerOutput <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the power ouput control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power ouput control (no more than 6 characters).',ext:''};
doc['PowerOutput']['get_logicalName']={syn:'Returns the logical name of the power ouput control.',lib:'YPowerOutput get_logicalName',pro:'YPowerOutput <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the power ouput control.</p>',ret:'a string corresponding to the logical name of the power ouput control.',ext:''};
doc['PowerOutput']['get_voltage']={syn:'Returns the voltage on the power ouput featured by the module.',lib:'YPowerOutput get_voltage',pro:'YPowerOutput <span id=pn>target</span> get_voltage',cmt:'<p>Returns the voltage on the power ouput featured by the module.</p>',ret:'a value among <tt>OFF</tt>, <tt>OUT3V3</tt> and <tt>OUT5V</tt> corresponding to the voltage on the power ouput featured by the module',ext:''};
doc['PowerOutput']['set_logicalName']={syn:'Changes the logical name of the power ouput control.',lib:'YPowerOutput set_logicalName',pro:'YPowerOutput <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the power ouput control.</p>',par:{newval:'a string corresponding to the logical name of the power ouput control.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['PowerOutput']['set_voltage']={syn:'Changes the voltage on the power output provided by the module.',lib:'YPowerOutput set_voltage',pro:'YPowerOutput <span id=pn>target</span> set_voltage <span id=pn>newval</span>',cmt:'<p>Changes the voltage on the power output provided by the module.</p>',par:{newval:'a value among <tt>OFF</tt>, <tt>OUT3V3</tt> and <tt>OUT5V</tt> corresponding to the voltage on the power output provided by the module'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: PowerOutput)
//--- (generated code: Cellular)
doc['Cellular']={'':{syn:'Cellular function interface',inc:'',cmt:'<p>YCellular functions provides control over cellular network parameters and status for devices that are GSM-enabled.</p>'}};
doc['Cellular']['_AT']={syn:'Sends an AT command to the GSM module and returns the command output.',lib:'YCellular _AT',pro:'YCellular <span id=pn>target</span> _AT <span id=pn>cmd</span>',cmt:'<p>Sends an AT command to the GSM module and returns the command output. The command will only execute when the GSM module is in standard command state, and should leave it in the exact same state. Use this function with great care !</p>',par:{cmd:'the AT command to execute, like for instance: \x22+CCLK?\x22.'},ret:'a string with the result of the commands. Empty lines are automatically removed from the output.'};
doc['Cellular']['get_advertisedValue']={syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'YCellular get_advertisedValue',pro:'YCellular <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:''};
doc['Cellular']['get_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'YCellular get_apn',pro:'YCellular <span id=pn>target</span> get_apn',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',ret:'a string corresponding to the Access Point Name (APN) to be used, if needed',ext:''};
doc['Cellular']['get_apnSecret']={syn:'Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise.',lib:'YCellular get_apnSecret',pro:'YCellular <span id=pn>target</span> get_apnSecret',cmt:'<p>Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise. To configure these parameters, use <tt>set_apnAuth()</tt>.</p>',ret:'a string corresponding to an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise',ext:''};
doc['Cellular']['get_cellOperator']={syn:'Returns the name of the cell operator currently in use.',lib:'YCellular get_cellOperator',pro:'YCellular <span id=pn>target</span> get_cellOperator',cmt:'<p>Returns the name of the cell operator currently in use.</p>',ret:'a string corresponding to the name of the cell operator currently in use',ext:''};
doc['Cellular']['get_enableData']={syn:'Returns the condition for enabling IP data services (GPRS).',lib:'YCellular get_enableData',pro:'YCellular <span id=pn>target</span> get_enableData',cmt:'<p>Returns the condition for enabling IP data services (GPRS). When data services are disabled, SMS are the only mean of communication.</p>',ret:'a value among <tt>HOMENETWORK</tt>, <tt>ROAMING</tt> and <tt>NEVER</tt> corresponding to the condition for enabling IP data services (GPRS)',ext:''};
doc['Cellular']['get_imsi']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'YCellular get_imsi',pro:'YCellular <span id=pn>target</span> get_imsi',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:''};
doc['Cellular']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'YCellular get_linkQuality',pro:'YCellular <span id=pn>target</span> get_linkQuality',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:''};
doc['Cellular']['get_lockedOperator']={syn:'Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.',lib:'YCellular get_lockedOperator',pro:'YCellular <span id=pn>target</span> get_lockedOperator',cmt:'<p>Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.</p>',ret:'a string corresponding to the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators',ext:''};
doc['Cellular']['get_logicalName']={syn:'Returns the logical name of the cellular interface.',lib:'YCellular get_logicalName',pro:'YCellular <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:''};
doc['Cellular']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'YCellular get_message',pro:'YCellular <span id=pn>target</span> get_message',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:''};
doc['Cellular']['get_pin']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'YCellular get_pin',pro:'YCellular <span id=pn>target</span> get_pin',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:''};
doc['Cellular']['quickCellSurvey']={syn:'Returns a list of nearby cellular antennas, as required for quick geolocation of the device.',lib:'YCellular quickCellSurvey',pro:'YCellular <span id=pn>target</span> quickCellSurvey',cmt:'<p>Returns a list of nearby cellular antennas, as required for quick geolocation of the device. The first cell listed is the serving cell, and the next ones are the neighboor cells reported by the serving cell.</p>',ret:'a list of YCellRecords.'};
doc['Cellular']['sendPUK']={syn:'Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card.',lib:'YCellular sendPUK',pro:'YCellular <span id=pn>target</span> sendPUK <span id=pn>puk</span> <span id=pn>newPin</span>',cmt:'<p>Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card. Only ten consecutives tentatives are permitted: after that, the SIM card will be blocked permanently without any mean of recovery to use it again. Note that after calling this method, you have usually to invoke method <tt>set_pin()</tt> to tell the YoctoHub which PIN to use in the future.</p>',par:{puk:'the SIM PUK code',newPin:'new PIN code to configure into the SIM card'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Cellular']['set_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'YCellular set_apn',pro:'YCellular <span id=pn>target</span> set_apn <span id=pn>newval</span>',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',par:{newval:'a string'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_apnAuth']={syn:'Configure authentication parameters to connect to the APN.',lib:'YCellular set_apnAuth',pro:'YCellular <span id=pn>target</span> set_apnAuth <span id=pn>username</span> <span id=pn>password</span>',cmt:'<p>Configure authentication parameters to connect to the APN. Both PAP and CHAP authentication are supported.</p>',par:{username:'APN username',password:'APN password'},ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['Cellular']['set_enableData']={syn:'Changes the condition for enabling IP data services (GPRS).',lib:'YCellular set_enableData',pro:'YCellular <span id=pn>target</span> set_enableData <span id=pn>newval</span>',cmt:'<p>Changes the condition for enabling IP data services (GPRS). The service can be either fully deactivated, or limited to the SIM home network, or enabled for all partner networks (roaming). Caution: enabling data services on roaming networks may cause prohibitive communication costs !</p><p> When data services are disabled, SMS are the only mean of communication.</p>',par:{newval:'a value among <tt>HOMENETWORK</tt>, <tt>ROAMING</tt> and <tt>NEVER</tt> corresponding to the condition for enabling IP data services (GPRS)'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_lockedOperator']={syn:'Changes the name of the cell operator to be used.',lib:'YCellular set_lockedOperator',pro:'YCellular <span id=pn>target</span> set_lockedOperator <span id=pn>newval</span>',cmt:'<p>Changes the name of the cell operator to be used. If the name is an empty string, the choice will be made automatically based on the SIM card. Otherwise, the selected operator is the only one that will be used.</p>',par:{newval:'a string corresponding to the name of the cell operator to be used'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_logicalName']={syn:'Changes the logical name of the cellular interface.',lib:'YCellular set_logicalName',pro:'YCellular <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the cellular interface.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Cellular']['set_pin']={syn:'Changes the PIN code used by the module to access the SIM card.',lib:'YCellular set_pin',pro:'YCellular <span id=pn>target</span> set_pin <span id=pn>newval</span>',cmt:'<p>Changes the PIN code used by the module to access the SIM card. This function does not change the code on the SIM card itself, but only changes the parameter used by the device to try to get access to it. If the SIM code does not work immediately on first try, it will be automatically forgotten and the message will be set to \x22Enter SIM PIN\x22. The method should then be invoked again with right correct PIN code. After three failed attempts in a row, the message is changed to \x22Enter SIM PUK\x22 and the SIM card PUK code must be provided using method <tt>sendPUK</tt>.</p>',par:{newval:'a string corresponding to the PIN code used by the module to access the SIM card'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: Cellular)
//--- (generated code: AudioOut)
doc['AudioOut']={'':{syn:'AudioOut function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to configure the volume of the outout.</p>'}};
doc['AudioOut']['get_advertisedValue']={syn:'Returns the current value of the audio output (no more than 6 characters).',lib:'YAudioOut get_advertisedValue',pro:'YAudioOut <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the audio output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio output (no more than 6 characters).',ext:''};
doc['AudioOut']['get_logicalName']={syn:'Returns the logical name of the audio output.',lib:'YAudioOut get_logicalName',pro:'YAudioOut <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the audio output.</p>',ret:'a string corresponding to the logical name of the audio output.',ext:''};
doc['AudioOut']['get_mute']={syn:'Returns the state of the mute function.',lib:'YAudioOut get_mute',pro:'YAudioOut <span id=pn>target</span> get_mute',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function',ext:''};
doc['AudioOut']['get_signal']={syn:'Returns the detected output current level.',lib:'YAudioOut get_signal',pro:'YAudioOut <span id=pn>target</span> get_signal',cmt:'<p>Returns the detected output current level.</p>',ret:'an integer corresponding to the detected output current level',ext:''};
doc['AudioOut']['get_volume']={syn:'Returns audio output volume, in per cents.',lib:'YAudioOut get_volume',pro:'YAudioOut <span id=pn>target</span> get_volume',cmt:'<p>Returns audio output volume, in per cents.</p>',ret:'an integer corresponding to audio output volume, in per cents',ext:''};
doc['AudioOut']['get_volumeRange']={syn:'Returns the supported volume range.',lib:'YAudioOut get_volumeRange',pro:'YAudioOut <span id=pn>target</span> get_volumeRange',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:''};
doc['AudioOut']['set_logicalName']={syn:'Changes the logical name of the audio output.',lib:'YAudioOut set_logicalName',pro:'YAudioOut <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the audio output.</p>',par:{newval:'a string corresponding to the logical name of the audio output.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioOut']['set_mute']={syn:'Changes the state of the mute function.',lib:'YAudioOut set_mute',pro:'YAudioOut <span id=pn>target</span> set_mute <span id=pn>newval</span>',cmt:'<p>Changes the state of the mute function.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioOut']['set_volume']={syn:'Changes audio output volume, in per cents.',lib:'YAudioOut set_volume',pro:'YAudioOut <span id=pn>target</span> set_volume <span id=pn>newval</span>',cmt:'<p>Changes audio output volume, in per cents.</p>',par:{newval:'an integer corresponding to audio output volume, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: AudioOut)
//--- (generated code: BluetoothLink)
doc['BluetoothLink']={'':{syn:'BluetoothLink function interface',inc:'',cmt:'<p>BluetoothLink function provides control over bluetooth link and status for devices that are bluetooth-enabled.</p>'}};
doc['BluetoothLink']['connect']={syn:'Attempt to connect to the previously selected remote device.',lib:'YBluetoothLink connect',pro:'YBluetoothLink <span id=pn>target</span> connect',cmt:'<p>Attempt to connect to the previously selected remote device.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['BluetoothLink']['disconnect']={syn:'Disconnect from the previously selected remote device.',lib:'YBluetoothLink disconnect',pro:'YBluetoothLink <span id=pn>target</span> disconnect',cmt:'<p>Disconnect from the previously selected remote device.</p>',ret:'<tt>OK</tt> when the call succeeds.',ext:''};
doc['BluetoothLink']['get_advertisedValue']={syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'YBluetoothLink get_advertisedValue',pro:'YBluetoothLink <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:''};
doc['BluetoothLink']['get_linkQuality']={syn:'Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.',lib:'YBluetoothLink get_linkQuality',pro:'YBluetoothLink <span id=pn>target</span> get_linkQuality',cmt:'<p>Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.</p>',ret:'an integer corresponding to the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established',ext:''};
doc['BluetoothLink']['get_linkState']={syn:'Returns the bluetooth link state.',lib:'YBluetoothLink get_linkState',pro:'YBluetoothLink <span id=pn>target</span> get_linkState',cmt:'<p>Returns the bluetooth link state.</p>',ret:'a value among <tt>DOWN</tt>, <tt>FREE</tt>, <tt>SEARCH</tt>, <tt>EXISTS</tt>, <tt>LINKED</tt> and <tt>PLAY</tt> corresponding to the bluetooth link state',ext:''};
doc['BluetoothLink']['get_logicalName']={syn:'Returns the logical name of the cellular interface.',lib:'YBluetoothLink get_logicalName',pro:'YBluetoothLink <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:''};
doc['BluetoothLink']['get_mute']={syn:'Returns the state of the mute function.',lib:'YBluetoothLink get_mute',pro:'YBluetoothLink <span id=pn>target</span> get_mute',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function',ext:''};
doc['BluetoothLink']['get_ownAddress']={syn:'Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.',lib:'YBluetoothLink get_ownAddress',pro:'YBluetoothLink <span id=pn>target</span> get_ownAddress',cmt:'<p>Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.</p>',ret:'a string corresponding to the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network',ext:''};
doc['BluetoothLink']['get_pairingPin']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'YBluetoothLink get_pairingPin',pro:'YBluetoothLink <span id=pn>target</span> get_pairingPin',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:''};
doc['BluetoothLink']['get_preAmplifier']={syn:'Returns the audio pre-amplifier volume, in per cents.',lib:'YBluetoothLink get_preAmplifier',pro:'YBluetoothLink <span id=pn>target</span> get_preAmplifier',cmt:'<p>Returns the audio pre-amplifier volume, in per cents.</p>',ret:'an integer corresponding to the audio pre-amplifier volume, in per cents',ext:''};
doc['BluetoothLink']['get_remoteAddress']={syn:'Returns the MAC-48 address of the remote device to connect to.',lib:'YBluetoothLink get_remoteAddress',pro:'YBluetoothLink <span id=pn>target</span> get_remoteAddress',cmt:'<p>Returns the MAC-48 address of the remote device to connect to.</p>',ret:'a string corresponding to the MAC-48 address of the remote device to connect to',ext:''};
doc['BluetoothLink']['get_remoteName']={syn:'Returns the bluetooth name the remote device, if found on the bluetooth network.',lib:'YBluetoothLink get_remoteName',pro:'YBluetoothLink <span id=pn>target</span> get_remoteName',cmt:'<p>Returns the bluetooth name the remote device, if found on the bluetooth network.</p>',ret:'a string corresponding to the bluetooth name the remote device, if found on the bluetooth network',ext:''};
doc['BluetoothLink']['get_volume']={syn:'Returns the connected headset volume, in per cents.',lib:'YBluetoothLink get_volume',pro:'YBluetoothLink <span id=pn>target</span> get_volume',cmt:'<p>Returns the connected headset volume, in per cents.</p>',ret:'an integer corresponding to the connected headset volume, in per cents',ext:''};
doc['BluetoothLink']['set_logicalName']={syn:'Changes the logical name of the cellular interface.',lib:'YBluetoothLink set_logicalName',pro:'YBluetoothLink <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the cellular interface.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_mute']={syn:'Changes the state of the mute function.',lib:'YBluetoothLink set_mute',pro:'YBluetoothLink <span id=pn>target</span> set_mute <span id=pn>newval</span>',cmt:'<p>Changes the state of the mute function.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_pairingPin']={syn:'Changes the PIN code used by the module for bluetooth pairing.',lib:'YBluetoothLink set_pairingPin',pro:'YBluetoothLink <span id=pn>target</span> set_pairingPin <span id=pn>newval</span>',cmt:'<p>Changes the PIN code used by the module for bluetooth pairing.</p>',par:{newval:'a string corresponding to the PIN code used by the module for bluetooth pairing'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_preAmplifier']={syn:'Changes the audio pre-amplifier volume, in per cents.',lib:'YBluetoothLink set_preAmplifier',pro:'YBluetoothLink <span id=pn>target</span> set_preAmplifier <span id=pn>newval</span>',cmt:'<p>Changes the audio pre-amplifier volume, in per cents.</p>',par:{newval:'an integer corresponding to the audio pre-amplifier volume, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_remoteAddress']={syn:'Changes the MAC-48 address defining which remote device to connect to.',lib:'YBluetoothLink set_remoteAddress',pro:'YBluetoothLink <span id=pn>target</span> set_remoteAddress <span id=pn>newval</span>',cmt:'<p>Changes the MAC-48 address defining which remote device to connect to.</p>',par:{newval:'a string corresponding to the MAC-48 address defining which remote device to connect to'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['BluetoothLink']['set_volume']={syn:'Changes the connected headset volume, in per cents.',lib:'YBluetoothLink set_volume',pro:'YBluetoothLink <span id=pn>target</span> set_volume <span id=pn>newval</span>',cmt:'<p>Changes the connected headset volume, in per cents.</p>',par:{newval:'an integer corresponding to the connected headset volume, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: BluetoothLink)
//--- (generated code: Sensor)
doc['Sensor']={'':{syn:'Sensor function interface',inc:'',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Sensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'YSensor calibrateFromPoints',pro:'YSensor <span id=pn>target</span> calibrateFromPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['get_advertisedValue']={syn:'Returns the current value of the sensor (no more than 6 characters).',lib:'YSensor get_advertisedValue',pro:'YSensor <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the sensor (no more than 6 characters).',ext:''};
doc['Sensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'YSensor get_currentRawValue',pro:'YSensor <span id=pn>target</span> get_currentRawValue',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:''};
doc['Sensor']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'YSensor get_currentValue',pro:'YSensor <span id=pn>target</span> get_currentValue',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:''};
doc['Sensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'YSensor get_highestValue',pro:'YSensor <span id=pn>target</span> get_highestValue',cmt:'<p>Returns the maximal value observed for the measure since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:''};
doc['Sensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'YSensor get_logFrequency',pro:'YSensor <span id=pn>target</span> get_logFrequency',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:''};
doc['Sensor']['get_logicalName']={syn:'Returns the logical name of the sensor.',lib:'YSensor get_logicalName',pro:'YSensor <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the sensor.</p>',ret:'a string corresponding to the logical name of the sensor.',ext:''};
doc['Sensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'YSensor get_lowestValue',pro:'YSensor <span id=pn>target</span> get_lowestValue',cmt:'<p>Returns the minimal value observed for the measure since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:''};
doc['Sensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'YSensor get_recordedData',pro:'YSensor <span id=pn>target</span> get_recordedData <span id=pn>startTime</span> <span id=pn>endTime</span>',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Sensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'YSensor get_reportFrequency',pro:'YSensor <span id=pn>target</span> get_reportFrequency',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:''};
doc['Sensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'YSensor get_resolution',pro:'YSensor <span id=pn>target</span> get_resolution',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:''};
doc['Sensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'YSensor get_sensorState',pro:'YSensor <span id=pn>target</span> get_sensorState',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:''};
doc['Sensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'YSensor get_unit',pro:'YSensor <span id=pn>target</span> get_unit',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:''};
doc['Sensor']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'YSensor isSensorReady',pro:'YSensor <span id=pn>target</span> isSensorReady',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Sensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'YSensor loadCalibrationPoints',pro:'YSensor <span id=pn>target</span> loadCalibrationPoints <span id=pn>rawValues</span> <span id=pn>refValues</span>',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'YSensor set_highestValue',pro:'YSensor <span id=pn>target</span> set_highestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'YSensor set_logFrequency',pro:'YSensor <span id=pn>target</span> set_logFrequency <span id=pn>newval</span>',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_logicalName']={syn:'Changes the logical name of the sensor.',lib:'YSensor set_logicalName',pro:'YSensor <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the sensor.</p>',par:{newval:'a string corresponding to the logical name of the sensor.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'YSensor set_lowestValue',pro:'YSensor <span id=pn>target</span> set_lowestValue <span id=pn>newval</span>',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'YSensor set_reportFrequency',pro:'YSensor <span id=pn>target</span> set_reportFrequency <span id=pn>newval</span>',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'YSensor set_resolution',pro:'YSensor <span id=pn>target</span> set_resolution <span id=pn>newval</span>',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['Sensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'YSensor startDataLogger',pro:'YSensor <span id=pn>target</span> startDataLogger',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
doc['Sensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'YSensor stopDataLogger',pro:'YSensor <span id=pn>target</span> stopDataLogger',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>OK</tt> if the call succeeds.'};
//--- (end of generated code: Sensor)
//--- (generated code: AudioIn)
doc['AudioIn']={'':{syn:'AudioIn function interface',inc:'',cmt:'<p>The Yoctopuce application programming interface allows you to configure the volume of the input channel.</p>'}};
doc['AudioIn']['get_advertisedValue']={syn:'Returns the current value of the audio input (no more than 6 characters).',lib:'YAudioIn get_advertisedValue',pro:'YAudioIn <span id=pn>target</span> get_advertisedValue',cmt:'<p>Returns the current value of the audio input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio input (no more than 6 characters).',ext:''};
doc['AudioIn']['get_logicalName']={syn:'Returns the logical name of the audio input.',lib:'YAudioIn get_logicalName',pro:'YAudioIn <span id=pn>target</span> get_logicalName',cmt:'<p>Returns the logical name of the audio input.</p>',ret:'a string corresponding to the logical name of the audio input.',ext:''};
doc['AudioIn']['get_mute']={syn:'Returns the state of the mute function.',lib:'YAudioIn get_mute',pro:'YAudioIn <span id=pn>target</span> get_mute',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function',ext:''};
doc['AudioIn']['get_signal']={syn:'Returns the detected input signal level.',lib:'YAudioIn get_signal',pro:'YAudioIn <span id=pn>target</span> get_signal',cmt:'<p>Returns the detected input signal level.</p>',ret:'an integer corresponding to the detected input signal level',ext:''};
doc['AudioIn']['get_volume']={syn:'Returns audio input gain, in per cents.',lib:'YAudioIn get_volume',pro:'YAudioIn <span id=pn>target</span> get_volume',cmt:'<p>Returns audio input gain, in per cents.</p>',ret:'an integer corresponding to audio input gain, in per cents',ext:''};
doc['AudioIn']['get_volumeRange']={syn:'Returns the supported volume range.',lib:'YAudioIn get_volumeRange',pro:'YAudioIn <span id=pn>target</span> get_volumeRange',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:''};
doc['AudioIn']['set_logicalName']={syn:'Changes the logical name of the audio input.',lib:'YAudioIn set_logicalName',pro:'YAudioIn <span id=pn>target</span> set_logicalName <span id=pn>newval</span>',cmt:'<p>Changes the logical name of the audio input.</p>',par:{newval:'a string corresponding to the logical name of the audio input.'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioIn']['set_mute']={syn:'Changes the state of the mute function.',lib:'YAudioIn set_mute',pro:'YAudioIn <span id=pn>target</span> set_mute <span id=pn>newval</span>',cmt:'<p>Changes the state of the mute function.</p>',par:{newval:'either <tt>FALSE</tt> or <tt>TRUE</tt>, according to the state of the mute function'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
doc['AudioIn']['set_volume']={syn:'Changes audio input gain, in per cents.',lib:'YAudioIn set_volume',pro:'YAudioIn <span id=pn>target</span> set_volume <span id=pn>newval</span>',cmt:'<p>Changes audio input gain, in per cents.</p>',par:{newval:'an integer corresponding to audio input gain, in per cents'},ret:'<tt>OK</tt> if the call succeeds.',ext:''};
//--- (end of generated code: AudioIn)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 }

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);
 }

function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);
 }

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 }

function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }

function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist."
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 }

function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }

function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."
    it.style.top  = parseInt(t) + "px";
 }

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }

function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }

function computeWinWH()
 { WinW             = GetWindowWidth() ;
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight();
   if (WinH<400) WinH=400;
}


 function getInnerHeight()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );
 }

 function getInnerWidth()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct)
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct;
  }

function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++)
      resizeCallBacks[i]();
  }

function jsQuote(str_in)
{ str_in = str_in+'';
  var str_out   = '';
  for (i=0;i<str_in.length;i++)
   {
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex;
      }
   }
   return str_out;
  }


function resizeMargin()
 {
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 }

function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110);
 }

function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 }

function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches)
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }
  return new positionObject(x,y);
 }


function EnableDrag(var_element,onDragMove,onDragEnd)
  {
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }
   else
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);

   if (onDragMove)  var_element.onDragMove = onDragMove;
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;
  }

 var LastDraggedObject = null;

 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos)
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;

   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }

   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }

   if (event.preventDefault)   event.preventDefault();
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source,
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    }
   document.onmouseup   =   Drag_stopMouseCapture;
 }


function Drag_mouseCapture(event)
 {
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault();


   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y);

   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;

   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;

   var p = {x:x,y:y};

   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);

   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;

   lastDraggedObject.element.style.left = p.x+"px";
   lastDraggedObject.element.style.top  = p.y+"px";
 }

function Drag_stopMouseCapture()
 {
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent)
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }

  if (lastDraggedObject)
    { lastDraggedObject.element.style.cursor='col-resize';
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }

 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin()
  }

 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  {
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }

    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex;
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par)
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'
          }

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }

         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml;
  }

  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }
  }

 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname)
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'><img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";

       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }
       }
       marginhtml = marginhtml+'</div>'
    }

    document.getElementById("MarginLayer").innerHTML = marginhtml;
  }

 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()

    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }

    for (var i=0;i<tosearch.length;i++)
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }

          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;

          if (!found) return false;
       }


    return true;

  }

 var searchTimer = null;

 function doSearch()
  { searchTimer = null;
    var value= document.forms['yoctoForm'].elements['search'].value;

    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           }
          container["originalDisplay"]=null;
        }
        Show(lastindex_shown,lastname_shown);
       return;
      }

    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');
       for (var method in doc[classname])

         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}
                 }
              else
                 { if (it) it.style.display="none";
                 }
         }

      if  (matchfound)
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }

    Show(firstindex,firstname);


  }

 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }

 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown);
    Show(lastindex_shown,lastname_shown);

  }




 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form>
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" >
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" '+ (UseShortcuts?'checked':'') + ' onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;


 }
doc = sortObject(doc);
ShowFunctions();
Show(doc["YAPI"]?"YAPI":"Module","");


window.onresize = windowResized;
-->
</script>

</BODY>


</HEAD>

